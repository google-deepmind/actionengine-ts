/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 * @suppress {lintChecks}
 */

// clang-format off
function n(n) { var t = "function" == typeof Symbol && Symbol.iterator, e = t && n[t], o = 0; if (e) return e.call(n); if (n && "number" == typeof n.length) return { next: function () { return n && o >= n.length && (n = void 0), { value: n && n[o++], done: !n } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") } function t(n) { return this instanceof t ? (this.v = n, this) : new t(n) } function e(n, e, o) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var i, s = o.apply(n, e || []), l = []; return i = Object.create(("function" == typeof AsyncIterator ? AsyncIterator : Object).prototype), r("next"), r("throw"), r("return", (function (n) { return function (t) { return Promise.resolve(t).then(n, u) } })), i[Symbol.asyncIterator] = function () { return this }, i; function r(n, t) { s[n] && (i[n] = function (t) { return new Promise((function (e, o) { l.push([n, t, e, o]) > 1 || a(n, t) })) }, t && (i[n] = t(i[n]))) } function a(n, e) { try { (o = s[n](e)).value instanceof t ? Promise.resolve(o.value.v).then(c, u) : p(l[0][2], o) } catch (n) { p(l[0][3], n) } var o } function c(n) { a("next", n) } function u(n) { a("throw", n) } function p(n, t) { n(t), l.shift(), l.length && a(l[0][0], l[0][1]) } } function o(t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var e, o = t[Symbol.asyncIterator]; return o ? o.call(t) : (t = n(t), e = {}, i("next"), i("throw"), i("return"), e[Symbol.asyncIterator] = function () { return this }, e); function i(n) { e[n] = t[n] && function (e) { return new Promise((function (o, i) { (function (n, t, e, o) { Promise.resolve(o).then((function (t) { n({ value: t, done: e }) }), t) })(o, i, (e = t[n](e)).done, e.value) })) } } } "function" == typeof SuppressedError && SuppressedError; class i { } function s(n, t) { return n.replace(/\{([^}]+)\}/g, ((n, e) => { if (t.hasOwnProperty(e)) return t[e]; throw new Error(`Key '${e}' not found in valueMap ${t}`) })) } function l(n, t, e) { for (let o = 0; o < t.length - 1; o++) { const i = t[o]; if (i.endsWith("[]")) { const s = i.slice(0, -2); if (!(s in n)) { if (!Array.isArray(e)) throw new Error(`value ${e} must be a list given an array path ${i}`); n[s] = Array.from({ length: e.length }, (() => ({}))) } if (Array.isArray(e)) for (let i = 0; i < n[s].length; i++)l(n[s][i], t.slice(o + 1), e[i]); else for (const i of n[s]) l(i, t.slice(o + 1), e); return } n[i] && "object" == typeof n[i] || (n[i] = {}), n = n[i] } n[t[t.length - 1]] = e } function r(n, t) { try { if (1 === t.length && "_self" === t[0]) return n; for (let e = 0; e < t.length; e++) { const o = t[e]; if (o.endsWith("[]")) { const i = o.slice(0, -2); return i in n ? n[i].map((n => r(n, t.slice(e + 1)))) : void 0 } n = n[o] } return n } catch (n) { if (n instanceof TypeError) return; throw n } } function a(n, t) { if (!t) throw new Error("model is required"); if (n.isVertexAI()) { if (t.startsWith("publishers/") || t.startsWith("projects/") || t.startsWith("models/")) return t; if (t.indexOf("/") >= 0) { const n = t.split("/", 2); return `publishers/${n[0]}/models/${n[1]}` } return `publishers/google/models/${t}` } return t.startsWith("models/") || t.startsWith("tunedModels/") ? t : `models/${t}` } function c(n, t) { const e = a(n, t); return e ? e.startsWith("publishers/") && n.isVertexAI() ? `projects/${n.getProject()}/locations/${n.getLocation()}/${e}` : e.startsWith("models/") && n.isVertexAI() ? `projects/${n.getProject()}/locations/${n.getLocation()}/publishers/google/${e}` : e : "" } function u(n, t) { if (!t) throw new Error("PartUnion is required"); if ("object" == typeof t) return t; if ("string" == typeof t) return { text: t }; throw new Error("Unsupported part type: " + typeof t) } function p(n, t) { if (!t) throw new Error("PartListUnion is required"); return Array.isArray(t) ? t.map((n => u(0, n))) : [u(0, t)] } function d(n, t) { if (!t) throw new Error("ContentUnion is required"); return "object" == typeof t && "parts" in t ? t : { role: "user", parts: p(0, t) } } function f(n, t) { return t ? n.isVertexAI() && Array.isArray(t) ? t.map((n => d(0, n).parts[0].text)) : n.isVertexAI() ? [d(0, t).parts[0].text] : Array.isArray(t) ? t.map((n => d(0, n))) : [d(0, t)] : [] } function m(n, t) { return t ? Array.isArray(t) ? t.map((n => d(0, n))) : [d(0, t)] : [] } function h(n, t) { if (!n.isVertexAI() && ("title" in t && delete t.title, "default" in t)) throw new Error("Default value is not supported in the response schema for the Gemini API."); if ("anyOf" in t) { if (!n.isVertexAI()) throw new Error("AnyOf is not supported in the response schema for the Gemini API."); if (void 0 !== t.anyOf) for (const e of t.anyOf) h(n, e) } } function g(n, t) { return h(n, t), t } function E(n, t) { if ("object" == typeof t && "voiceConfig" in t) return t; if ("string" == typeof t) return { voiceConfig: { prebuiltVoiceConfig: { voiceName: t } } }; throw new Error("Unsupported speechConfig type: " + typeof t) } function C(n, t) { return t } function v(n, t) { return t } function I(n, t) { return function (n, t, e, o = 1) { const i = !t.startsWith(`${e}/`) && t.split("/").length === o; return n.isVertexAI() ? t.startsWith("projects/") ? t : t.startsWith("locations/") ? `projects/${n.getProject()}/${t}` : t.startsWith(`${e}/`) ? `projects/${n.getProject()}/locations/${n.getLocation()}/${t}` : i ? `projects/${n.getProject()}/locations/${n.getLocation()}/${e}/${t}` : t : i ? `${e}/${t}` : t }(n, t, "cachedContents") } function O(n, t) { switch (t) { case "STATE_UNSPECIFIED": return "JOB_STATE_UNSPECIFIED"; case "CREATING": return "JOB_STATE_RUNNING"; case "ACTIVE": return "JOB_STATE_SUCCEEDED"; case "FAILED": return "JOB_STATE_FAILED"; default: return t } } function T(n, t) { return t } var _, A, y, S, R, w, D, N, P, x, M, b, L, U, G, B, H, F, k, V, j, Y, J, $, q, K; !function (n) { n.OUTCOME_UNSPECIFIED = "OUTCOME_UNSPECIFIED", n.OUTCOME_OK = "OUTCOME_OK", n.OUTCOME_FAILED = "OUTCOME_FAILED", n.OUTCOME_DEADLINE_EXCEEDED = "OUTCOME_DEADLINE_EXCEEDED" }(_ || (_ = {})), function (n) { n.LANGUAGE_UNSPECIFIED = "LANGUAGE_UNSPECIFIED", n.PYTHON = "PYTHON" }(A || (A = {})), function (n) { n.TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED", n.STRING = "STRING", n.NUMBER = "NUMBER", n.INTEGER = "INTEGER", n.BOOLEAN = "BOOLEAN", n.ARRAY = "ARRAY", n.OBJECT = "OBJECT" }(y || (y = {})), function (n) { n.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED", n.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH", n.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT", n.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT", n.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT", n.HARM_CATEGORY_CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY" }(S || (S = {})), function (n) { n.HARM_BLOCK_METHOD_UNSPECIFIED = "HARM_BLOCK_METHOD_UNSPECIFIED", n.SEVERITY = "SEVERITY", n.PROBABILITY = "PROBABILITY" }(R || (R = {})), function (n) { n.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED", n.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", n.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", n.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", n.BLOCK_NONE = "BLOCK_NONE", n.OFF = "OFF" }(w || (w = {})), function (n) { n.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", n.MODE_DYNAMIC = "MODE_DYNAMIC" }(D || (D = {})), function (n) { n.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED", n.STOP = "STOP", n.MAX_TOKENS = "MAX_TOKENS", n.SAFETY = "SAFETY", n.RECITATION = "RECITATION", n.OTHER = "OTHER", n.BLOCKLIST = "BLOCKLIST", n.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", n.SPII = "SPII", n.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL" }(N || (N = {})), function (n) { n.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED", n.NEGLIGIBLE = "NEGLIGIBLE", n.LOW = "LOW", n.MEDIUM = "MEDIUM", n.HIGH = "HIGH" }(P || (P = {})), function (n) { n.HARM_SEVERITY_UNSPECIFIED = "HARM_SEVERITY_UNSPECIFIED", n.HARM_SEVERITY_NEGLIGIBLE = "HARM_SEVERITY_NEGLIGIBLE", n.HARM_SEVERITY_LOW = "HARM_SEVERITY_LOW", n.HARM_SEVERITY_MEDIUM = "HARM_SEVERITY_MEDIUM", n.HARM_SEVERITY_HIGH = "HARM_SEVERITY_HIGH" }(x || (x = {})), function (n) { n.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED", n.SAFETY = "SAFETY", n.OTHER = "OTHER", n.BLOCKLIST = "BLOCKLIST", n.PROHIBITED_CONTENT = "PROHIBITED_CONTENT" }(M || (M = {})), function (n) { n.JOB_STATE_UNSPECIFIED = "JOB_STATE_UNSPECIFIED", n.JOB_STATE_QUEUED = "JOB_STATE_QUEUED", n.JOB_STATE_PENDING = "JOB_STATE_PENDING", n.JOB_STATE_RUNNING = "JOB_STATE_RUNNING", n.JOB_STATE_SUCCEEDED = "JOB_STATE_SUCCEEDED", n.JOB_STATE_FAILED = "JOB_STATE_FAILED", n.JOB_STATE_CANCELLING = "JOB_STATE_CANCELLING", n.JOB_STATE_CANCELLED = "JOB_STATE_CANCELLED", n.JOB_STATE_PAUSED = "JOB_STATE_PAUSED", n.JOB_STATE_EXPIRED = "JOB_STATE_EXPIRED", n.JOB_STATE_UPDATING = "JOB_STATE_UPDATING", n.JOB_STATE_PARTIALLY_SUCCEEDED = "JOB_STATE_PARTIALLY_SUCCEEDED" }(b || (b = {})), function (n) { n.ADAPTER_SIZE_UNSPECIFIED = "ADAPTER_SIZE_UNSPECIFIED", n.ADAPTER_SIZE_ONE = "ADAPTER_SIZE_ONE", n.ADAPTER_SIZE_FOUR = "ADAPTER_SIZE_FOUR", n.ADAPTER_SIZE_EIGHT = "ADAPTER_SIZE_EIGHT", n.ADAPTER_SIZE_SIXTEEN = "ADAPTER_SIZE_SIXTEEN", n.ADAPTER_SIZE_THIRTY_TWO = "ADAPTER_SIZE_THIRTY_TWO" }(L || (L = {})), function (n) { n.STATE_UNSPECIFIED = "STATE_UNSPECIFIED", n.ACTIVE = "ACTIVE", n.ERROR = "ERROR" }(U || (U = {})), function (n) { n.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", n.MODE_DYNAMIC = "MODE_DYNAMIC" }(G || (G = {})), function (n) { n.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", n.AUTO = "AUTO", n.ANY = "ANY", n.NONE = "NONE" }(B || (B = {})), function (n) { n.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED", n.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW", n.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM", n.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH" }(H || (H = {})), function (n) { n.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", n.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", n.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", n.BLOCK_NONE = "BLOCK_NONE" }(F || (F = {})), function (n) { n.DONT_ALLOW = "DONT_ALLOW", n.ALLOW_ADULT = "ALLOW_ADULT", n.ALLOW_ALL = "ALLOW_ALL" }(k || (k = {})), function (n) { n.auto = "auto", n.en = "en", n.ja = "ja", n.ko = "ko", n.hi = "hi" }(V || (V = {})), function (n) { n.STATE_UNSPECIFIED = "STATE_UNSPECIFIED", n.PROCESSING = "PROCESSING", n.ACTIVE = "ACTIVE", n.FAILED = "FAILED" }(j || (j = {})), function (n) { n.SOURCE_UNSPECIFIED = "SOURCE_UNSPECIFIED", n.UPLOADED = "UPLOADED", n.GENERATED = "GENERATED" }(Y || (Y = {})), function (n) { n.MASK_MODE_DEFAULT = "MASK_MODE_DEFAULT", n.MASK_MODE_USER_PROVIDED = "MASK_MODE_USER_PROVIDED", n.MASK_MODE_BACKGROUND = "MASK_MODE_BACKGROUND", n.MASK_MODE_FOREGROUND = "MASK_MODE_FOREGROUND", n.MASK_MODE_SEMANTIC = "MASK_MODE_SEMANTIC" }(J || (J = {})), function (n) { n.CONTROL_TYPE_DEFAULT = "CONTROL_TYPE_DEFAULT", n.CONTROL_TYPE_CANNY = "CONTROL_TYPE_CANNY", n.CONTROL_TYPE_SCRIBBLE = "CONTROL_TYPE_SCRIBBLE", n.CONTROL_TYPE_FACE_MESH = "CONTROL_TYPE_FACE_MESH" }($ || ($ = {})), function (n) { n.SUBJECT_TYPE_DEFAULT = "SUBJECT_TYPE_DEFAULT", n.SUBJECT_TYPE_PERSON = "SUBJECT_TYPE_PERSON", n.SUBJECT_TYPE_ANIMAL = "SUBJECT_TYPE_ANIMAL", n.SUBJECT_TYPE_PRODUCT = "SUBJECT_TYPE_PRODUCT" }(q || (q = {})), function (n) { n.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", n.TEXT = "TEXT", n.IMAGE = "IMAGE", n.AUDIO = "AUDIO" }(K || (K = {})); class W { } class z { } class X { } class Z { text() { var n, t, e, o, i, s, l, r; if (0 === (null === (o = null === (e = null === (t = null === (n = null == this ? void 0 : this.candidates) || void 0 === n ? void 0 : n[0]) || void 0 === t ? void 0 : t.content) || void 0 === e ? void 0 : e.parts) || void 0 === o ? void 0 : o.length)) return; (null == this ? void 0 : this.candidates) && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning text from the first one."); let a = "", c = !1; for (const n of null !== (r = null === (l = null === (s = null === (i = null == this ? void 0 : this.candidates) || void 0 === i ? void 0 : i[0]) || void 0 === s ? void 0 : s.content) || void 0 === l ? void 0 : l.parts) && void 0 !== r ? r : []) { for (const [t, e] of Object.entries(n)) if ("text" !== t && "thought" !== t && (null !== e || void 0 !== e)) throw new Error(`GenerateContentResponse.text only supports text parts, but got ${t} part ${JSON.stringify(n)}`); if ("string" == typeof n.text) { if ("boolean" == typeof n.thought && n.thought) continue; c = !0, a += n.text } } return c ? a : void 0 } functionCalls() { var n, t, e, o, i, s, l, r; if (0 === (null === (o = null === (e = null === (t = null === (n = null == this ? void 0 : this.candidates) || void 0 === n ? void 0 : n[0]) || void 0 === t ? void 0 : t.content) || void 0 === e ? void 0 : e.parts) || void 0 === o ? void 0 : o.length)) return; (null == this ? void 0 : this.candidates) && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning function calls from the first one."); const a = null === (r = null === (l = null === (s = null === (i = null == this ? void 0 : this.candidates) || void 0 === i ? void 0 : i[0]) || void 0 === s ? void 0 : s.content) || void 0 === l ? void 0 : l.parts) || void 0 === r ? void 0 : r.filter((n => n.functionCall)).map((n => n.functionCall)).filter((n => void 0 !== n)); return 0 !== (null == a ? void 0 : a.length) ? a : void 0 } } class Q { } class nn { } class tn { } class en { } class on { } class sn { } class ln { } class rn { } class an { } class cn { } function un(n, t) { return { fileData: { fileUri: n, mimeType: t } } } function pn(n) { return { text: n } } function dn(n, t) { return { functionCall: { name: n, args: t } } } function fn(n, t, e) { return { functionResponse: { id: n, name: t, response: e } } } function mn(n, t) { return { inlineData: { data: n, mimeType: t } } } function hn(n, t) { return { videoMetadata: { startOffset: n, endOffset: t } } } function gn(n, t) { return { codeExecutionResult: { outcome: n, output: t } } } function En(n, t) { return { executableCode: { code: n, language: t } } } class Cn extends i { constructor(n) { super(), this.apiClient = n, this.generateContent = async n => await this.generateContentInternal(n), this.generateContentStream = async n => await this.generateContentStreamInternal(n) } async generateContentInternal(n) { var t, e; let o, i = "", l = {}; const r = {}; return r.model = n.model, r.contents = n.contents, r.config = n.config, this.apiClient.isVertexAI() ? (l = Mn(this.apiClient, r), i = s("{model}:generateContent", l._url), delete l.config, o = this.apiClient.post(i, l, Z, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => { const t = Hn(this.apiClient, n); let e = new Z; return Object.assign(e, t), e }))) : (l = xn(this.apiClient, r), i = s("{model}:generateContent", l._url), delete l.config, o = this.apiClient.post(i, l, Z, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => { const t = Bn(this.apiClient, n); let e = new Z; return Object.assign(e, t), e }))) } async generateContentStreamInternal(n) { var i, l; let r, a = "", c = {}; const u = {}; if (u.model = n.model, u.contents = n.contents, u.config = n.config, this.apiClient.isVertexAI()) { c = Mn(this.apiClient, u), a = s("{model}:streamGenerateContent?alt=sse", c._url), delete c.config, r = this.apiClient.postStream(a, c, Z, null === (i = n.config) || void 0 === i ? void 0 : i.httpOptions); let l = this.apiClient; return r.then((function (n) { return e(this, arguments, (function* () { var e, i, s, r; try { for (var a, c = !0, u = o(n); !(e = (a = yield t(u.next())).done); c = !0) { r = a.value, c = !1; const n = Hn(l, r); let e = new Z; Object.assign(e, n), yield yield t(e) } } catch (n) { i = { error: n } } finally { try { c || e || !(s = u.return) || (yield t(s.call(u))) } finally { if (i) throw i.error } } })) })) } { c = xn(this.apiClient, u), a = s("{model}:streamGenerateContent?alt=sse", c._url), delete c.config, r = this.apiClient.postStream(a, c, Z, null === (l = n.config) || void 0 === l ? void 0 : l.httpOptions); const i = this.apiClient; return r.then((function (n) { return e(this, arguments, (function* () { var e, s, l, r; try { for (var a, c = !0, u = o(n); !(e = (a = yield t(u.next())).done); c = !0) { r = a.value, c = !1; const n = Bn(i, r); let e = new Z; Object.assign(e, n), yield yield t(e) } } catch (n) { s = { error: n } } finally { try { c || e || !(l = u.return) || (yield t(l.call(u))) } finally { if (s) throw s.error } } })) })) } } async embedContent(n) { var t, e; let o, i = "", c = {}; const u = {}; return u.model = n.model, u.contents = n.contents, u.config = n.config, this.apiClient.isVertexAI() ? (c = function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["_url", "model"], a(n, o)); const i = r(t, ["contents"]); null != i && l(e, ["instances[]", "content"], f(n, i)); const s = r(t, ["config"]); null != s && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["taskType"]); void 0 !== e && null != i && l(e, ["instances[]", "task_type"], i); const s = r(t, ["title"]); void 0 !== e && null != s && l(e, ["instances[]", "title"], s); const a = r(t, ["outputDimensionality"]); void 0 !== e && null != a && l(e, ["parameters", "outputDimensionality"], a); const c = r(t, ["mimeType"]); void 0 !== e && null != c && l(e, ["instances[]", "mimeType"], c); const u = r(t, ["autoTruncate"]); void 0 !== e && null != u && l(e, ["parameters", "autoTruncate"], u); return o }(0, s, e)); return e }(this.apiClient, u), i = s("{model}:predict", c._url), delete c.config, o = this.apiClient.post(i, c, Q, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["predictions[]", "embeddings"]); null != o && l(e, ["embeddings"], o.map((n => function (n, t) { const e = {}, o = r(t, ["values"]); null != o && l(e, ["values"], o); const i = r(t, ["statistics"]); null != i && l(e, ["statistics"], function (n, t) { const e = {}, o = r(t, ["truncated"]); null != o && l(e, ["truncated"], o); const i = r(t, ["token_count"]); null != i && l(e, ["tokenCount"], i); return e }(0, i)); return e }(0, n)))); const i = r(t, ["metadata"]); null != i && l(e, ["metadata"], function (n, t) { const e = {}, o = r(t, ["billableCharacterCount"]); null != o && l(e, ["billableCharacterCount"], o); return e }(0, i)); return e }(this.apiClient, n); let e = new Q; return Object.assign(e, t), e }))) : (c = function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["_url", "model"], a(n, o)); const i = r(t, ["contents"]); null != i && l(e, ["requests[]", "content"], f(n, i)); const s = r(t, ["config"]); null != s && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["taskType"]); void 0 !== e && null != i && l(e, ["requests[]", "taskType"], i); const s = r(t, ["title"]); void 0 !== e && null != s && l(e, ["requests[]", "title"], s); const a = r(t, ["outputDimensionality"]); void 0 !== e && null != a && l(e, ["requests[]", "outputDimensionality"], a); if (void 0 !== r(t, ["mimeType"])) throw new Error("mimeType parameter is not supported in Gemini API."); if (void 0 !== r(t, ["autoTruncate"])) throw new Error("autoTruncate parameter is not supported in Gemini API."); return o }(0, s, e)); const c = r(t, ["model"]); void 0 !== c && l(e, ["requests[]", "model"], a(n, c)); return e }(this.apiClient, u), i = s("{model}:batchEmbedContents", c._url), delete c.config, o = this.apiClient.post(i, c, Q, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["embeddings"]); null != o && l(e, ["embeddings"], o.map((n => function (n, t) { const e = {}, o = r(t, ["values"]); null != o && l(e, ["values"], o); return e }(0, n)))); const i = r(t, ["metadata"]); null != i && l(e, ["metadata"], function () { const n = {}; return n }()); return e }(this.apiClient, n); let e = new Q; return Object.assign(e, t), e }))) } async generateImages(n) { var t, e; let o, i = "", c = {}; const u = {}; return u.model = n.model, u.prompt = n.prompt, u.config = n.config, this.apiClient.isVertexAI() ? (c = function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["_url", "model"], a(n, o)); const i = r(t, ["prompt"]); null != i && l(e, ["instances", "prompt"], i); const s = r(t, ["config"]); null != s && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["outputGcsUri"]); void 0 !== e && null != i && l(e, ["parameters", "storageUri"], i); const s = r(t, ["negativePrompt"]); void 0 !== e && null != s && l(e, ["parameters", "negativePrompt"], s); const a = r(t, ["numberOfImages"]); void 0 !== e && null != a && l(e, ["parameters", "sampleCount"], a); const c = r(t, ["guidanceScale"]); void 0 !== e && null != c && l(e, ["parameters", "guidanceScale"], c); const u = r(t, ["seed"]); void 0 !== e && null != u && l(e, ["parameters", "seed"], u); const p = r(t, ["safetyFilterLevel"]); void 0 !== e && null != p && l(e, ["parameters", "safetySetting"], p); const d = r(t, ["personGeneration"]); void 0 !== e && null != d && l(e, ["parameters", "personGeneration"], d); const f = r(t, ["includeSafetyAttributes"]); void 0 !== e && null != f && l(e, ["parameters", "includeSafetyAttributes"], f); const m = r(t, ["includeRaiReason"]); void 0 !== e && null != m && l(e, ["parameters", "includeRaiReason"], m); const h = r(t, ["language"]); void 0 !== e && null != h && l(e, ["parameters", "language"], h); const g = r(t, ["outputMimeType"]); void 0 !== e && null != g && l(e, ["parameters", "outputOptions", "mimeType"], g); const E = r(t, ["outputCompressionQuality"]); void 0 !== e && null != E && l(e, ["parameters", "outputOptions", "compressionQuality"], E); const C = r(t, ["addWatermark"]); void 0 !== e && null != C && l(e, ["parameters", "addWatermark"], C); const v = r(t, ["aspectRatio"]); void 0 !== e && null != v && l(e, ["parameters", "aspectRatio"], v); const I = r(t, ["enhancePrompt"]); void 0 !== e && null != I && l(e, ["parameters", "enhancePrompt"], I); return o }(0, s, e)); return e }(this.apiClient, u), i = s("{model}:predict", c._url), delete c.config, o = this.apiClient.post(i, c, nn, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["predictions"]); null != o && l(e, ["generatedImages"], o.map((n => function (n, t) { const e = {}, o = r(t, ["_self"]); null != o && l(e, ["image"], function (n, t) { const e = {}, o = r(t, ["gcsUri"]); null != o && l(e, ["gcsUri"], o); const i = r(t, ["bytesBase64Encoded"]); null != i && l(e, ["imageBytes"], T(0, i)); const s = r(t, ["mimeType"]); null != s && l(e, ["mimeType"], s); return e }(0, o)); const i = r(t, ["raiFilteredReason"]); null != i && l(e, ["raiFilteredReason"], i); const s = r(t, ["prompt"]); null != s && l(e, ["enhancedPrompt"], s); return e }(0, n)))); return e }(this.apiClient, n); let e = new nn; return Object.assign(e, t), e }))) : (c = function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["_url", "model"], a(n, o)); const i = r(t, ["prompt"]); null != i && l(e, ["instances", "prompt"], i); const s = r(t, ["config"]); null != s && l(e, ["config"], function (n, t, e) { const o = {}; if (void 0 !== r(t, ["outputGcsUri"])) throw new Error("outputGcsUri parameter is not supported in Gemini API."); const i = r(t, ["negativePrompt"]); void 0 !== e && null != i && l(e, ["parameters", "negativePrompt"], i); const s = r(t, ["numberOfImages"]); void 0 !== e && null != s && l(e, ["parameters", "sampleCount"], s); const a = r(t, ["guidanceScale"]); void 0 !== e && null != a && l(e, ["parameters", "guidanceScale"], a); if (void 0 !== r(t, ["seed"])) throw new Error("seed parameter is not supported in Gemini API."); const c = r(t, ["safetyFilterLevel"]); void 0 !== e && null != c && l(e, ["parameters", "safetySetting"], c); const u = r(t, ["personGeneration"]); void 0 !== e && null != u && l(e, ["parameters", "personGeneration"], u); const p = r(t, ["includeSafetyAttributes"]); void 0 !== e && null != p && l(e, ["parameters", "includeSafetyAttributes"], p); const d = r(t, ["includeRaiReason"]); void 0 !== e && null != d && l(e, ["parameters", "includeRaiReason"], d); const f = r(t, ["language"]); void 0 !== e && null != f && l(e, ["parameters", "language"], f); const m = r(t, ["outputMimeType"]); void 0 !== e && null != m && l(e, ["parameters", "outputOptions", "mimeType"], m); const h = r(t, ["outputCompressionQuality"]); void 0 !== e && null != h && l(e, ["parameters", "outputOptions", "compressionQuality"], h); if (void 0 !== r(t, ["addWatermark"])) throw new Error("addWatermark parameter is not supported in Gemini API."); const g = r(t, ["aspectRatio"]); void 0 !== e && null != g && l(e, ["parameters", "aspectRatio"], g); if (void 0 !== r(t, ["enhancePrompt"])) throw new Error("enhancePrompt parameter is not supported in Gemini API."); return o }(0, s, e)); return e }(this.apiClient, u), i = s("{model}:predict", c._url), delete c.config, o = this.apiClient.post(i, c, nn, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["predictions"]); null != o && l(e, ["generatedImages"], o.map((n => function (n, t) { const e = {}, o = r(t, ["_self"]); null != o && l(e, ["image"], function (n, t) { const e = {}, o = r(t, ["bytesBase64Encoded"]); null != o && l(e, ["imageBytes"], T(0, o)); const i = r(t, ["mimeType"]); null != i && l(e, ["mimeType"], i); return e }(0, o)); const i = r(t, ["raiFilteredReason"]); null != i && l(e, ["raiFilteredReason"], i); return e }(0, n)))); return e }(this.apiClient, n); let e = new nn; return Object.assign(e, t), e }))) } async countTokens(n) { var t, e; let o, i = "", c = {}; const u = {}; return u.model = n.model, u.contents = n.contents, u.config = n.config, this.apiClient.isVertexAI() ? (c = function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["_url", "model"], a(n, o)); const i = r(t, ["contents"]); null != i && l(e, ["contents"], m(0, m(0, i).map((t => In(n, t))))); const s = r(t, ["config"]); null != s && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["systemInstruction"]); void 0 !== e && null != i && l(e, ["systemInstruction"], In(n, d(0, i))); const s = r(t, ["tools"]); void 0 !== e && null != s && l(e, ["tools"], s.map((t => yn(n, t)))); const a = r(t, ["generationConfig"]); void 0 !== e && null != a && l(e, ["generationConfig"], a); return o }(n, s, e)); return e }(this.apiClient, u), i = s("{model}:countTokens", c._url), delete c.config, o = this.apiClient.post(i, c, tn, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["totalTokens"]); null != o && l(e, ["totalTokens"], o); return e }(this.apiClient, n); let e = new tn; return Object.assign(e, t), e }))) : (c = function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["_url", "model"], a(n, o)); const i = r(t, ["contents"]); null != i && l(e, ["contents"], m(0, m(0, i).map((t => vn(n, t))))); const s = r(t, ["config"]); null != s && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["systemInstruction"]); void 0 !== e && null != i && l(e, ["generateContentRequest", "systemInstruction"], vn(n, d(0, i))); const s = r(t, ["tools"]); void 0 !== e && null != s && l(e, ["generateContentRequest", "tools"], s.map((t => An(n, t)))); if (void 0 !== r(t, ["generationConfig"])) throw new Error("generationConfig parameter is not supported in Gemini API."); return o }(n, s, e)); return e }(this.apiClient, u), i = s("{model}:countTokens", c._url), delete c.config, o = this.apiClient.post(i, c, tn, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["totalTokens"]); null != o && l(e, ["totalTokens"], o); const i = r(t, ["cachedContentTokenCount"]); null != i && l(e, ["cachedContentTokenCount"], i); return e }(this.apiClient, n); let e = new tn; return Object.assign(e, t), e }))) } async computeTokens(n) { var t, e; let o, i = "", c = {}; const u = {}; return u.model = n.model, u.contents = n.contents, u.config = n.config, this.apiClient.isVertexAI() ? (c = function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["_url", "model"], a(n, o)); const i = r(t, ["contents"]); null != i && l(e, ["contents"], m(0, m(0, i).map((t => In(n, t))))); const s = r(t, ["config"]); null != s && l(e, ["config"], s); return e }(this.apiClient, u), i = s("{model}:computeTokens", c._url), delete c.config, o = this.apiClient.post(i, c, en, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["tokensInfo"]); null != o && l(e, ["tokensInfo"], o); return e }(this.apiClient, n); let e = new en; return Object.assign(e, t), e }))) : (c = function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["_url", "model"], a(n, o)); if (void 0 !== r(t, ["contents"])) throw new Error("contents parameter is not supported in Gemini API."); const i = r(t, ["config"]); null != i && l(e, ["config"], i); return e }(this.apiClient, u), i = s("None", c._url), delete c.config, o = this.apiClient.post(i, c, en, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["tokensInfo"]); null != o && l(e, ["tokensInfo"], o); return e }(this.apiClient, n); let e = new en; return Object.assign(e, t), e }))) } } function vn(n, t, e) { const o = {}, i = r(t, ["parts"]); null != i && l(o, ["parts"], i.map((n => function (n, t) { const e = {}; if (void 0 !== r(t, ["videoMetadata"])) throw new Error("videoMetadata parameter is not supported in Gemini API."); const o = r(t, ["thought"]); null != o && l(e, ["thought"], o); const i = r(t, ["codeExecutionResult"]); null != i && l(e, ["codeExecutionResult"], i); const s = r(t, ["executableCode"]); null != s && l(e, ["executableCode"], s); const a = r(t, ["fileData"]); null != a && l(e, ["fileData"], a); const c = r(t, ["functionCall"]); null != c && l(e, ["functionCall"], c); const u = r(t, ["functionResponse"]); null != u && l(e, ["functionResponse"], u); const p = r(t, ["inlineData"]); null != p && l(e, ["inlineData"], p); const d = r(t, ["text"]); return null != d && l(e, ["text"], d), e }(0, n)))); const s = r(t, ["role"]); return null != s && l(o, ["role"], s), o } function In(n, t, e) { const o = {}, i = r(t, ["parts"]); null != i && l(o, ["parts"], i.map((n => function (n, t) { const e = {}, o = r(t, ["videoMetadata"]); null != o && l(e, ["videoMetadata"], o); const i = r(t, ["thought"]); null != i && l(e, ["thought"], i); const s = r(t, ["codeExecutionResult"]); null != s && l(e, ["codeExecutionResult"], s); const a = r(t, ["executableCode"]); null != a && l(e, ["executableCode"], a); const c = r(t, ["fileData"]); null != c && l(e, ["fileData"], c); const u = r(t, ["functionCall"]); null != u && l(e, ["functionCall"], u); const p = r(t, ["functionResponse"]); null != p && l(e, ["functionResponse"], p); const d = r(t, ["inlineData"]); null != d && l(e, ["inlineData"], d); const f = r(t, ["text"]); return null != f && l(e, ["text"], f), e }(0, n)))); const s = r(t, ["role"]); return null != s && l(o, ["role"], s), o } function On(n, t, e) { const o = {}, i = r(t, ["minItems"]); null != i && l(o, ["minItems"], i); const s = r(t, ["example"]); null != s && l(o, ["example"], s); const a = r(t, ["propertyOrdering"]); null != a && l(o, ["propertyOrdering"], a); const c = r(t, ["pattern"]); null != c && l(o, ["pattern"], c); const u = r(t, ["minimum"]); null != u && l(o, ["minimum"], u); const p = r(t, ["default"]); null != p && l(o, ["default"], p); const d = r(t, ["anyOf"]); null != d && l(o, ["anyOf"], d); const f = r(t, ["maxLength"]); null != f && l(o, ["maxLength"], f); const m = r(t, ["title"]); null != m && l(o, ["title"], m); const h = r(t, ["minLength"]); null != h && l(o, ["minLength"], h); const g = r(t, ["minProperties"]); null != g && l(o, ["minProperties"], g); const E = r(t, ["maxItems"]); null != E && l(o, ["maxItems"], E); const C = r(t, ["maximum"]); null != C && l(o, ["maximum"], C); const v = r(t, ["nullable"]); null != v && l(o, ["nullable"], v); const I = r(t, ["maxProperties"]); null != I && l(o, ["maxProperties"], I); const O = r(t, ["type"]); null != O && l(o, ["type"], O); const T = r(t, ["description"]); null != T && l(o, ["description"], T); const _ = r(t, ["enum"]); null != _ && l(o, ["enum"], _); const A = r(t, ["format"]); null != A && l(o, ["format"], A); const y = r(t, ["items"]); null != y && l(o, ["items"], y); const S = r(t, ["properties"]); null != S && l(o, ["properties"], S); const R = r(t, ["required"]); return null != R && l(o, ["required"], R), o } function Tn(n, t, e) { const o = {}, i = r(t, ["dynamicRetrievalConfig"]); return null != i && l(o, ["dynamicRetrievalConfig"], function (n, t) { const e = {}, o = r(t, ["mode"]); null != o && l(e, ["mode"], o); const i = r(t, ["dynamicThreshold"]); return null != i && l(e, ["dynamicThreshold"], i), e }(0, i)), o } function _n(n, t, e) { const o = {}, i = r(t, ["dynamicRetrievalConfig"]); return null != i && l(o, ["dynamicRetrievalConfig"], function (n, t) { const e = {}, o = r(t, ["mode"]); null != o && l(e, ["mode"], o); const i = r(t, ["dynamicThreshold"]); return null != i && l(e, ["dynamicThreshold"], i), e }(0, i)), o } function An(n, t, e) { const o = {}, i = r(t, ["functionDeclarations"]); if (null != i && l(o, ["functionDeclarations"], i.map((n => function (n, t) { const e = {}; if (void 0 !== r(t, ["response"])) throw new Error("response parameter is not supported in Gemini API."); const o = r(t, ["description"]); null != o && l(e, ["description"], o); const i = r(t, ["name"]); null != i && l(e, ["name"], i); const s = r(t, ["parameters"]); return null != s && l(e, ["parameters"], s), e }(0, n)))), void 0 !== r(t, ["retrieval"])) throw new Error("retrieval parameter is not supported in Gemini API."); const s = r(t, ["googleSearch"]); null != s && l(o, ["googleSearch"], {}); const a = r(t, ["googleSearchRetrieval"]); null != a && l(o, ["googleSearchRetrieval"], Tn(0, a)); const c = r(t, ["codeExecution"]); return null != c && l(o, ["codeExecution"], c), o } function yn(n, t, e) { const o = {}, i = r(t, ["functionDeclarations"]); null != i && l(o, ["functionDeclarations"], i.map((n => function (n, t) { const e = {}, o = r(t, ["response"]); null != o && l(e, ["response"], On(0, o)); const i = r(t, ["description"]); null != i && l(e, ["description"], i); const s = r(t, ["name"]); null != s && l(e, ["name"], s); const a = r(t, ["parameters"]); return null != a && l(e, ["parameters"], a), e }(0, n)))); const s = r(t, ["retrieval"]); null != s && l(o, ["retrieval"], s); const a = r(t, ["googleSearch"]); null != a && l(o, ["googleSearch"], {}); const c = r(t, ["googleSearchRetrieval"]); null != c && l(o, ["googleSearchRetrieval"], _n(0, c)); const u = r(t, ["codeExecution"]); return null != u && l(o, ["codeExecution"], u), o } function Sn(n, t, e) { const o = {}, i = r(t, ["functionCallingConfig"]); return null != i && l(o, ["functionCallingConfig"], function (n, t) { const e = {}, o = r(t, ["mode"]); null != o && l(e, ["mode"], o); const i = r(t, ["allowedFunctionNames"]); return null != i && l(e, ["allowedFunctionNames"], i), e }(0, i)), o } function Rn(n, t, e) { const o = {}, i = r(t, ["functionCallingConfig"]); return null != i && l(o, ["functionCallingConfig"], function (n, t) { const e = {}, o = r(t, ["mode"]); null != o && l(e, ["mode"], o); const i = r(t, ["allowedFunctionNames"]); return null != i && l(e, ["allowedFunctionNames"], i), e }(0, i)), o } function wn(n, t, e) { const o = {}, i = r(t, ["prebuiltVoiceConfig"]); return null != i && l(o, ["prebuiltVoiceConfig"], function (n, t) { const e = {}, o = r(t, ["voiceName"]); return null != o && l(e, ["voiceName"], o), e }(0, i)), o } function Dn(n, t, e) { const o = {}, i = r(t, ["prebuiltVoiceConfig"]); return null != i && l(o, ["prebuiltVoiceConfig"], function (n, t) { const e = {}, o = r(t, ["voiceName"]); return null != o && l(e, ["voiceName"], o), e }(0, i)), o } function Nn(n, t, e) { const o = {}, i = r(t, ["systemInstruction"]); void 0 !== e && null != i && l(e, ["systemInstruction"], vn(0, d(0, i))); const s = r(t, ["temperature"]); null != s && l(o, ["temperature"], s); const a = r(t, ["topP"]); null != a && l(o, ["topP"], a); const c = r(t, ["topK"]); null != c && l(o, ["topK"], c); const u = r(t, ["candidateCount"]); null != u && l(o, ["candidateCount"], u); const p = r(t, ["maxOutputTokens"]); null != p && l(o, ["maxOutputTokens"], p); const f = r(t, ["stopSequences"]); null != f && l(o, ["stopSequences"], f); const m = r(t, ["responseLogprobs"]); null != m && l(o, ["responseLogprobs"], m); const h = r(t, ["logprobs"]); null != h && l(o, ["logprobs"], h); const O = r(t, ["presencePenalty"]); null != O && l(o, ["presencePenalty"], O); const T = r(t, ["frequencyPenalty"]); null != T && l(o, ["frequencyPenalty"], T); const _ = r(t, ["seed"]); null != _ && l(o, ["seed"], _); const A = r(t, ["responseMimeType"]); null != A && l(o, ["responseMimeType"], A); const y = r(t, ["responseSchema"]); if (null != y && l(o, ["responseSchema"], function (n, t) { const e = {}; if (void 0 !== r(t, ["minItems"])) throw new Error("minItems parameter is not supported in Gemini API."); if (void 0 !== r(t, ["example"])) throw new Error("example parameter is not supported in Gemini API."); const o = r(t, ["propertyOrdering"]); if (null != o && l(e, ["propertyOrdering"], o), void 0 !== r(t, ["pattern"])) throw new Error("pattern parameter is not supported in Gemini API."); if (void 0 !== r(t, ["minimum"])) throw new Error("minimum parameter is not supported in Gemini API."); if (void 0 !== r(t, ["default"])) throw new Error("default parameter is not supported in Gemini API."); if (void 0 !== r(t, ["anyOf"])) throw new Error("anyOf parameter is not supported in Gemini API."); if (void 0 !== r(t, ["maxLength"])) throw new Error("maxLength parameter is not supported in Gemini API."); if (void 0 !== r(t, ["title"])) throw new Error("title parameter is not supported in Gemini API."); if (void 0 !== r(t, ["minLength"])) throw new Error("minLength parameter is not supported in Gemini API."); if (void 0 !== r(t, ["minProperties"])) throw new Error("minProperties parameter is not supported in Gemini API."); if (void 0 !== r(t, ["maxItems"])) throw new Error("maxItems parameter is not supported in Gemini API."); if (void 0 !== r(t, ["maximum"])) throw new Error("maximum parameter is not supported in Gemini API."); if (void 0 !== r(t, ["nullable"])) throw new Error("nullable parameter is not supported in Gemini API."); if (void 0 !== r(t, ["maxProperties"])) throw new Error("maxProperties parameter is not supported in Gemini API."); const i = r(t, ["type"]); null != i && l(e, ["type"], i); const s = r(t, ["description"]); null != s && l(e, ["description"], s); const a = r(t, ["enum"]); null != a && l(e, ["enum"], a); const c = r(t, ["format"]); null != c && l(e, ["format"], c); const u = r(t, ["items"]); null != u && l(e, ["items"], u); const p = r(t, ["properties"]); null != p && l(e, ["properties"], p); const d = r(t, ["required"]); return null != d && l(e, ["required"], d), e }(0, g(n, y))), void 0 !== r(t, ["routingConfig"])) throw new Error("routingConfig parameter is not supported in Gemini API."); const S = r(t, ["safetySettings"]); void 0 !== e && null != S && l(e, ["safetySettings"], S.map((n => function (n, t) { const e = {}; if (void 0 !== r(t, ["method"])) throw new Error("method parameter is not supported in Gemini API."); const o = r(t, ["category"]); null != o && l(e, ["category"], o); const i = r(t, ["threshold"]); return null != i && l(e, ["threshold"], i), e }(0, n)))); const R = r(t, ["tools"]); void 0 !== e && null != R && l(e, ["tools"], v(0, v(0, R).map((n => An(0, C(0, n)))))); const w = r(t, ["toolConfig"]); if (void 0 !== e && null != w && l(e, ["toolConfig"], Sn(0, w)), void 0 !== r(t, ["labels"])) throw new Error("labels parameter is not supported in Gemini API."); const D = r(t, ["cachedContent"]); void 0 !== e && null != D && l(e, ["cachedContent"], I(n, D)); const N = r(t, ["responseModalities"]); null != N && l(o, ["responseModalities"], N); const P = r(t, ["mediaResolution"]); null != P && l(o, ["mediaResolution"], P); const x = r(t, ["speechConfig"]); if (null != x && l(o, ["speechConfig"], function (n, t) { const e = {}, o = r(t, ["voiceConfig"]); return null != o && l(e, ["voiceConfig"], wn(0, o)), e }(0, E(0, x))), void 0 !== r(t, ["audioTimestamp"])) throw new Error("audioTimestamp parameter is not supported in Gemini API."); const M = r(t, ["thinkingConfig"]); return null != M && l(o, ["thinkingConfig"], function (n, t) { const e = {}, o = r(t, ["includeThoughts"]); return null != o && l(e, ["includeThoughts"], o), e }(0, M)), o } function Pn(n, t, e) { const o = {}, i = r(t, ["systemInstruction"]); void 0 !== e && null != i && l(e, ["systemInstruction"], In(0, d(0, i))); const s = r(t, ["temperature"]); null != s && l(o, ["temperature"], s); const a = r(t, ["topP"]); null != a && l(o, ["topP"], a); const c = r(t, ["topK"]); null != c && l(o, ["topK"], c); const u = r(t, ["candidateCount"]); null != u && l(o, ["candidateCount"], u); const p = r(t, ["maxOutputTokens"]); null != p && l(o, ["maxOutputTokens"], p); const f = r(t, ["stopSequences"]); null != f && l(o, ["stopSequences"], f); const m = r(t, ["responseLogprobs"]); null != m && l(o, ["responseLogprobs"], m); const h = r(t, ["logprobs"]); null != h && l(o, ["logprobs"], h); const O = r(t, ["presencePenalty"]); null != O && l(o, ["presencePenalty"], O); const T = r(t, ["frequencyPenalty"]); null != T && l(o, ["frequencyPenalty"], T); const _ = r(t, ["seed"]); null != _ && l(o, ["seed"], _); const A = r(t, ["responseMimeType"]); null != A && l(o, ["responseMimeType"], A); const y = r(t, ["responseSchema"]); null != y && l(o, ["responseSchema"], On(0, g(n, y))); const S = r(t, ["routingConfig"]); null != S && l(o, ["routingConfig"], S); const R = r(t, ["safetySettings"]); void 0 !== e && null != R && l(e, ["safetySettings"], R.map((n => function (n, t) { const e = {}, o = r(t, ["method"]); null != o && l(e, ["method"], o); const i = r(t, ["category"]); null != i && l(e, ["category"], i); const s = r(t, ["threshold"]); return null != s && l(e, ["threshold"], s), e }(0, n)))); const w = r(t, ["tools"]); void 0 !== e && null != w && l(e, ["tools"], v(0, v(0, w).map((n => yn(0, C(0, n)))))); const D = r(t, ["toolConfig"]); void 0 !== e && null != D && l(e, ["toolConfig"], Rn(0, D)); const N = r(t, ["labels"]); void 0 !== e && null != N && l(e, ["labels"], N); const P = r(t, ["cachedContent"]); void 0 !== e && null != P && l(e, ["cachedContent"], I(n, P)); const x = r(t, ["responseModalities"]); null != x && l(o, ["responseModalities"], x); const M = r(t, ["mediaResolution"]); null != M && l(o, ["mediaResolution"], M); const b = r(t, ["speechConfig"]); null != b && l(o, ["speechConfig"], function (n, t) { const e = {}, o = r(t, ["voiceConfig"]); return null != o && l(e, ["voiceConfig"], Dn(0, o)), e }(0, E(0, b))); const L = r(t, ["audioTimestamp"]); null != L && l(o, ["audioTimestamp"], L); const U = r(t, ["thinkingConfig"]); return null != U && l(o, ["thinkingConfig"], function (n, t) { const e = {}, o = r(t, ["includeThoughts"]); return null != o && l(e, ["includeThoughts"], o), e }(0, U)), o } function xn(n, t, e) { const o = {}, i = r(t, ["model"]); null != i && l(o, ["_url", "model"], a(n, i)); const s = r(t, ["contents"]); null != s && l(o, ["contents"], m(0, m(0, s).map((n => vn(0, n))))); const c = r(t, ["config"]); return null != c && l(o, ["generationConfig"], Nn(n, c, o)), o } function Mn(n, t, e) { const o = {}, i = r(t, ["model"]); null != i && l(o, ["_url", "model"], a(n, i)); const s = r(t, ["contents"]); null != s && l(o, ["contents"], m(0, m(0, s).map((n => In(0, n))))); const c = r(t, ["config"]); return null != c && l(o, ["generationConfig"], Pn(n, c, o)), o } function bn(n, t, e) { const o = {}, i = r(t, ["parts"]); null != i && l(o, ["parts"], i.map((n => function (n, t) { const e = {}, o = r(t, ["thought"]); null != o && l(e, ["thought"], o); const i = r(t, ["codeExecutionResult"]); null != i && l(e, ["codeExecutionResult"], i); const s = r(t, ["executableCode"]); null != s && l(e, ["executableCode"], s); const a = r(t, ["fileData"]); null != a && l(e, ["fileData"], a); const c = r(t, ["functionCall"]); null != c && l(e, ["functionCall"], c); const u = r(t, ["functionResponse"]); null != u && l(e, ["functionResponse"], u); const p = r(t, ["inlineData"]); null != p && l(e, ["inlineData"], p); const d = r(t, ["text"]); return null != d && l(e, ["text"], d), e }(0, n)))); const s = r(t, ["role"]); return null != s && l(o, ["role"], s), o } function Ln(n, t, e) { const o = {}, i = r(t, ["parts"]); null != i && l(o, ["parts"], i.map((n => function (n, t) { const e = {}, o = r(t, ["videoMetadata"]); null != o && l(e, ["videoMetadata"], o); const i = r(t, ["thought"]); null != i && l(e, ["thought"], i); const s = r(t, ["codeExecutionResult"]); null != s && l(e, ["codeExecutionResult"], s); const a = r(t, ["executableCode"]); null != a && l(e, ["executableCode"], a); const c = r(t, ["fileData"]); null != c && l(e, ["fileData"], c); const u = r(t, ["functionCall"]); null != u && l(e, ["functionCall"], u); const p = r(t, ["functionResponse"]); null != p && l(e, ["functionResponse"], p); const d = r(t, ["inlineData"]); null != d && l(e, ["inlineData"], d); const f = r(t, ["text"]); return null != f && l(e, ["text"], f), e }(0, n)))); const s = r(t, ["role"]); return null != s && l(o, ["role"], s), o } function Un(n, t, e) { const o = {}, i = r(t, ["content"]); null != i && l(o, ["content"], bn(0, i)); const s = r(t, ["citationMetadata"]); null != s && l(o, ["citationMetadata"], function (n, t) { const e = {}, o = r(t, ["citationSources"]); return null != o && l(e, ["citations"], o), e }(0, s)); const a = r(t, ["tokenCount"]); null != a && l(o, ["tokenCount"], a); const c = r(t, ["avgLogprobs"]); null != c && l(o, ["avgLogprobs"], c); const u = r(t, ["finishReason"]); null != u && l(o, ["finishReason"], u); const p = r(t, ["groundingMetadata"]); null != p && l(o, ["groundingMetadata"], p); const d = r(t, ["index"]); null != d && l(o, ["index"], d); const f = r(t, ["logprobsResult"]); null != f && l(o, ["logprobsResult"], f); const m = r(t, ["safetyRatings"]); return null != m && l(o, ["safetyRatings"], m), o } function Gn(n, t, e) { const o = {}, i = r(t, ["content"]); null != i && l(o, ["content"], Ln(0, i)); const s = r(t, ["citationMetadata"]); null != s && l(o, ["citationMetadata"], function (n, t) { const e = {}, o = r(t, ["citations"]); return null != o && l(e, ["citations"], o), e }(0, s)); const a = r(t, ["finishMessage"]); null != a && l(o, ["finishMessage"], a); const c = r(t, ["avgLogprobs"]); null != c && l(o, ["avgLogprobs"], c); const u = r(t, ["finishReason"]); null != u && l(o, ["finishReason"], u); const p = r(t, ["groundingMetadata"]); null != p && l(o, ["groundingMetadata"], p); const d = r(t, ["index"]); null != d && l(o, ["index"], d); const f = r(t, ["logprobsResult"]); null != f && l(o, ["logprobsResult"], f); const m = r(t, ["safetyRatings"]); return null != m && l(o, ["safetyRatings"], m), o } function Bn(n, t, e) { const o = {}, i = r(t, ["candidates"]); null != i && l(o, ["candidates"], i.map((n => Un(0, n)))); const s = r(t, ["modelVersion"]); null != s && l(o, ["modelVersion"], s); const a = r(t, ["promptFeedback"]); null != a && l(o, ["promptFeedback"], a); const c = r(t, ["usageMetadata"]); return null != c && l(o, ["usageMetadata"], c), o } function Hn(n, t, e) { const o = {}, i = r(t, ["candidates"]); null != i && l(o, ["candidates"], i.map((n => Gn(0, n)))); const s = r(t, ["modelVersion"]); null != s && l(o, ["modelVersion"], s); const a = r(t, ["promptFeedback"]); null != a && l(o, ["promptFeedback"], a); const c = r(t, ["usageMetadata"]); return null != c && l(o, ["usageMetadata"], c), o } const Fn = /^data: (.*)(?:\n\n|\r\r|\r\n\r\n)/; class kn extends Error { constructor(n, t) { super(n, t ? { cause: t } : { cause: (new Error).stack }), this.message = n, this.name = "ClientError" } } class Vn extends Error { constructor(n, t) { super(n, t ? { cause: t } : { cause: (new Error).stack }), this.message = n, this.name = "ServerError" } } class jn { constructor(n) { var t, e; this.clientOptions = Object.assign(Object.assign({}, n), { project: n.project, location: n.location, apiKey: n.apiKey, vertexai: n.vertexai }); const o = {}; this.clientOptions.vertexai ? (o.apiVersion = null !== (t = this.clientOptions.apiVersion) && void 0 !== t ? t : "v1beta1", o.baseUrl = `https://${this.clientOptions.location}-aiplatform.googleapis.com/`, this.clientOptions.apiKey = void 0) : (o.apiVersion = null !== (e = this.clientOptions.apiVersion) && void 0 !== e ? e : "v1beta", o.baseUrl = "https://generativelanguage.googleapis.com/"), o.headers = this.getDefaultHeaders(), this.clientOptions.httpOptions = o, n.httpOptions && (this.clientOptions.httpOptions = this.patchHttpOptions(o, n.httpOptions)) } isVertexAI() { var n; return null !== (n = this.clientOptions.vertexai) && void 0 !== n && n } getProject() { return this.clientOptions.project } getLocation() { return this.clientOptions.location } getApiVersion() { return this.clientOptions.httpOptions.apiVersion } getBaseUrl() { return this.clientOptions.httpOptions.baseUrl } getRequestUrl() { return this.getRequestUrlInternal(this.clientOptions.httpOptions) } getHeaders() { return this.clientOptions.httpOptions.headers } getRequestUrlInternal(n) { return n.baseUrl.endsWith("/") ? `${n.baseUrl}${n.apiVersion}` : `${n.baseUrl}/${n.apiVersion}` } getBaseResourcePath() { return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}` } getApiKey() { return this.clientOptions.apiKey } getWebsocketBaseUrl() { const n = this.getBaseUrl(), t = new URL(n); return t.protocol = "wss", t.toString() } setBaseUrl(n) { this.clientOptions.httpOptions.baseUrl = n } get(n, t, e, o) { return this.request(n, t, "GET", e, o) } post(n, t, e, o) { return this.request(n, t, "POST", e, o) } patch(n, t, e, o) { return this.request(n, t, "PATCH", e, o) } delete(n, t, e, o) { return this.request(n, t, "DELETE", e, o) } async request(n, t, e, o, i) { let s = JSON.parse(JSON.stringify(t)); delete s._url; let l = this.clientOptions.httpOptions; i && (l = this.patchHttpOptions(this.clientOptions.httpOptions, i)), this.clientOptions.vertexai && !n.startsWith("projects/") && (n = `${this.getBaseResourcePath()}/${n}`); const r = new URL(`${this.getRequestUrlInternal(l)}/${n}`); if (s._query) { for (const [n, t] of Object.entries(s._query)) r.searchParams.append(n, String(t)); delete s._query } s.config && (Object.assign(s, s.config), delete s.config); let a = {}; const c = JSON.stringify(s); if ("GET" === e) { if ("{}" !== c) throw new Error(`Request body should be empty for GET request, but got: ${c}`) } else a.body = c; return a = await this.includeExtraHttpOptionsToRequestInit(a, l), this.unaryApiCall(r, a, e, o) } patchHttpOptions(n, t) { let e = JSON.parse(JSON.stringify(n)); for (const [n, o] of Object.entries(t)) "object" == typeof o ? e[n] = Object.assign(Object.assign({}, e[n]), o) : o && (e[n] = o); return e } async postStream(n, t, e, o) { delete t._url; let i = this.clientOptions.httpOptions; o && (i = this.patchHttpOptions(this.clientOptions.httpOptions, o)), this.clientOptions.vertexai && !n.startsWith("projects/") && (n = `${this.getBaseResourcePath()}/${n}`); const s = new URL(`${this.getRequestUrlInternal(i)}/${n}`); s.searchParams.has("alt") && "sse" === s.searchParams.get("alt") || s.searchParams.set("alt", "sse"); let l = {}; return l.body = JSON.stringify(t), l = await this.includeExtraHttpOptionsToRequestInit(l, i), this.streamApiCall(s, l, "POST", e) } async includeExtraHttpOptionsToRequestInit(n, t) { if (t && t.timeout && t.timeout > 0) { const e = new AbortController, o = e.signal; setTimeout((() => e.abort()), t.timeout), n.signal = o } return n.headers = await this.getHeadersInternal(t), n } async unaryApiCall(n, t, e, o) { return this.apiCall(n.toString(), Object.assign(Object.assign({}, t), { method: e })).then((async e => (await Yn(e, n.toString(), t), e.json()))).catch((n => { throw n instanceof Error ? n : new Error(JSON.stringify(n)) })) } async streamApiCall(n, t, e, o) { return this.apiCall(n.toString(), Object.assign(Object.assign({}, t), { method: e })).then((async e => (await Yn(e, n.toString(), t), this.processStreamResponse(e, o)))).catch((n => { throw n instanceof Error ? n : new Error(JSON.stringify(n)) })) } processStreamResponse(n, o) { var i; return e(this, arguments, (function* () { const e = null === (i = null == n ? void 0 : n.body) || void 0 === i ? void 0 : i.getReader(), s = new TextDecoder("utf-8"); if (!e) throw new Error("Response body is empty"); try { let n = ""; for (; ;) { const { done: i, value: l } = yield t(e.read()); if (i) { if (n.trim().length > 0) throw new Error(`Incomplete JSON segment at the end: ${n}`); break } n += s.decode(l); let r = n.match(Fn); for (; r;) { const e = r[1]; try { const i = JSON.parse(e); if (o) { let n = new o; Object.assign(n, i), yield yield t(n) } else yield yield t(i); n = n.slice(r[0].length), r = n.match(Fn) } catch (n) { throw new Error(`exception parsing stream chunk ${e}. ${n}`) } } } } finally { e.releaseLock() } })) } async apiCall(n, t) { return fetch(n, t).catch((e => { throw new Error(`exception ${e} sending request to url: ${n} with requestInit: ${JSON.stringify(t)}}`) })) } getDefaultHeaders() { const n = {}, t = "google-genai-sdk/0.1.0 " + this.clientOptions.userAgentExtra; return n["User-Agent"] = t, n["x-goog-api-client"] = t, n["Content-Type"] = "application/json", n } async getHeadersInternal(n) { const t = new Headers; if (n && n.headers) for (const [e, o] of Object.entries(n.headers)) t.append(e, o); return await this.clientOptions.auth.addAuthHeaders(t), t } } async function Yn(n, t, e) { var o; if (void 0 === n) throw new Vn("response is undefined"); if (!n.ok) { const i = n.status, s = n.statusText; let l; l = (null === (o = n.headers.get("content-type")) || void 0 === o ? void 0 : o.includes("application/json")) ? await n.json() : { error: { message: `exception parsing response from url: ${t} with requestInit: ${JSON.stringify(e)}}`, code: n.status, status: n.statusText } }; const r = `got status: ${i} ${s}. ${JSON.stringify(l)}`; if (i >= 400 && i < 500) { throw new kn(r) } if (i >= 500 && i < 600) { throw new Vn(r) } throw new Error(r) } } const Jn = "x-goog-api-key"; class $n { constructor(n) { this.apiKey = n } async addAuthHeaders(n) { null === n.get(Jn) && n.append(Jn, this.apiKey) } } var qn; !function (n) { n.PAGED_ITEM_BATCH_JOBS = "batchJobs", n.PAGED_ITEM_MODELS = "models", n.PAGED_ITEM_TUNING_JOBS = "tuningJobs", n.PAGED_ITEM_FILES = "files", n.PAGED_ITEM_CACHED_CONTENTS = "cachedContents" }(qn || (qn = {})); class Kn { init(n, t, e, o) { var i; this.nameInternal = n, this.requestInternal = t, this.pageInternal = e[this.nameInternal] || [], this.idxInternal = 0; let s = {}; s = o ? "object" == typeof o ? Object.assign({}, o) : o : {}, s.pageToken = e.nextPageToken, this.configInternal = s, this.pageInternalSize = null !== (i = s.pageSize) && void 0 !== i ? i : this.pageInternal.length } constructor(n, t, e, o) { this.pageInternal = [], this.init(n, t, e, o) } page() { return this.pageInternal } name() { return this.nameInternal } pageSize() { return this.pageInternalSize } config() { return this.configInternal } len() { return this.pageInternal.length } getItem(n) { return this.pageInternal[n] } initNextPage(n) { this.init(this.nameInternal, this.requestInternal, n, this.configInternal) } } class Wn extends Kn { constructor(n, t, e, o) { super(n, t, e, o) } [Symbol.asyncIterator]() { return { next: async () => { if (this.idxInternal >= this.len()) try { this.nextPage() } catch (n) { return { value: void 0, done: !0 } } let n = this.getItem(this.idxInternal); return this.idxInternal += 1, { value: n, done: !1 } }, return: async () => ({ value: void 0, done: !0 }) } } nextPage() { if (!this.config().pageToken) throw new Error("No more pages to fetch."); let n = this.requestInternal(this.config()); return this.initNextPage(n), this.page() } } class zn extends i { constructor(n) { super(), this.apiClient = n, this.list = async (n = {}) => new Wn(qn.PAGED_ITEM_CACHED_CONTENTS, this.listInternal, await this.listInternal(n), n.config) } async create(n) { var t, e; let o, i = "", a = {}; const u = {}; return u.model = n.model, u.config = n.config, this.apiClient.isVertexAI() ? (a = function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["model"], c(n, o)); const i = r(t, ["config"]); null != i && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["ttl"]); void 0 !== e && null != i && l(e, ["ttl"], i); const s = r(t, ["expireTime"]); void 0 !== e && null != s && l(e, ["expireTime"], s); const a = r(t, ["displayName"]); void 0 !== e && null != a && l(e, ["displayName"], a); const c = r(t, ["contents"]); void 0 !== e && null != c && l(e, ["contents"], m(0, m(0, c).map((t => Zn(n, t))))); const u = r(t, ["systemInstruction"]); void 0 !== e && null != u && l(e, ["systemInstruction"], Zn(n, d(0, u))); const p = r(t, ["tools"]); void 0 !== e && null != p && l(e, ["tools"], p.map((t => ot(n, t)))); const f = r(t, ["toolConfig"]); void 0 !== e && null != f && l(e, ["toolConfig"], function (n, t) { const e = {}, o = r(t, ["functionCallingConfig"]); null != o && l(e, ["functionCallingConfig"], function (n, t) { const e = {}, o = r(t, ["mode"]); null != o && l(e, ["mode"], o); const i = r(t, ["allowedFunctionNames"]); null != i && l(e, ["allowedFunctionNames"], i); return e }(0, o)); return e }(0, f)); return o }(n, i, e)); return e }(this.apiClient, u), i = s("cachedContents", a._url), delete a.config, o = this.apiClient.post(i, a, void 0, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => st(this.apiClient, n)))) : (a = function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["model"], c(n, o)); const i = r(t, ["config"]); null != i && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["ttl"]); void 0 !== e && null != i && l(e, ["ttl"], i); const s = r(t, ["expireTime"]); void 0 !== e && null != s && l(e, ["expireTime"], s); const a = r(t, ["displayName"]); void 0 !== e && null != a && l(e, ["displayName"], a); const c = r(t, ["contents"]); void 0 !== e && null != c && l(e, ["contents"], m(0, m(0, c).map((t => Xn(n, t))))); const u = r(t, ["systemInstruction"]); void 0 !== e && null != u && l(e, ["systemInstruction"], Xn(n, d(0, u))); const p = r(t, ["tools"]); void 0 !== e && null != p && l(e, ["tools"], p.map((t => et(n, t)))); const f = r(t, ["toolConfig"]); void 0 !== e && null != f && l(e, ["toolConfig"], function (n, t) { const e = {}, o = r(t, ["functionCallingConfig"]); null != o && l(e, ["functionCallingConfig"], function (n, t) { const e = {}, o = r(t, ["mode"]); null != o && l(e, ["mode"], o); const i = r(t, ["allowedFunctionNames"]); null != i && l(e, ["allowedFunctionNames"], i); return e }(0, o)); return e }(0, f)); return o }(n, i, e)); return e }(this.apiClient, u), i = s("cachedContents", a._url), delete a.config, o = this.apiClient.post(i, a, void 0, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => it(this.apiClient, n)))) } async get(n) { var t, e; let o, i = "", a = {}; const c = {}; return c.name = n.name, c.config = n.config, this.apiClient.isVertexAI() ? (a = function (n, t) { const e = {}, o = r(t, ["name"]); null != o && l(e, ["_url", "name"], I(n, o)); const i = r(t, ["config"]); null != i && l(e, ["config"], i); return e }(this.apiClient, c), i = s("{name}", a._url), delete a.config, o = this.apiClient.get(i, a, void 0, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => st(this.apiClient, n)))) : (a = function (n, t) { const e = {}, o = r(t, ["name"]); null != o && l(e, ["_url", "name"], I(n, o)); const i = r(t, ["config"]); null != i && l(e, ["config"], i); return e }(this.apiClient, c), i = s("{name}", a._url), delete a.config, o = this.apiClient.get(i, a, void 0, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => it(this.apiClient, n)))) } async delete(n) { var t, e; let o, i = "", a = {}; const c = {}; return c.name = n.name, c.config = n.config, this.apiClient.isVertexAI() ? (a = function (n, t) { const e = {}, o = r(t, ["name"]); null != o && l(e, ["_url", "name"], I(n, o)); const i = r(t, ["config"]); null != i && l(e, ["config"], i); return e }(this.apiClient, c), i = s("{name}", a._url), delete a.config, o = this.apiClient.delete(i, a, sn, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => { const t = (this.apiClient, {}); let e = new sn; return Object.assign(e, t), e }))) : (a = function (n, t) { const e = {}, o = r(t, ["name"]); null != o && l(e, ["_url", "name"], I(n, o)); const i = r(t, ["config"]); null != i && l(e, ["config"], i); return e }(this.apiClient, c), i = s("{name}", a._url), delete a.config, o = this.apiClient.delete(i, a, sn, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => { const t = (this.apiClient, {}); let e = new sn; return Object.assign(e, t), e }))) } async update(n) { var t, e; let o, i = "", a = {}; const c = {}; return c.name = n.name, c.config = n.config, this.apiClient.isVertexAI() ? (a = function (n, t) { const e = {}, o = r(t, ["name"]); null != o && l(e, ["_url", "name"], I(n, o)); const i = r(t, ["config"]); null != i && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["ttl"]); void 0 !== e && null != i && l(e, ["ttl"], i); const s = r(t, ["expireTime"]); void 0 !== e && null != s && l(e, ["expireTime"], s); return o }(0, i, e)); return e }(this.apiClient, c), i = s("{name}", a._url), delete a.config, o = this.apiClient.patch(i, a, void 0, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => st(this.apiClient, n)))) : (a = function (n, t) { const e = {}, o = r(t, ["name"]); null != o && l(e, ["_url", "name"], I(n, o)); const i = r(t, ["config"]); null != i && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["ttl"]); void 0 !== e && null != i && l(e, ["ttl"], i); const s = r(t, ["expireTime"]); void 0 !== e && null != s && l(e, ["expireTime"], s); return o }(0, i, e)); return e }(this.apiClient, c), i = s("{name}", a._url), delete a.config, o = this.apiClient.patch(i, a, void 0, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => it(this.apiClient, n)))) } async listInternal(n) { var t, e; let o, i = "", a = {}; const c = {}; return c.config = n.config, this.apiClient.isVertexAI() ? (a = function (n, t) { const e = {}, o = r(t, ["config"]); null != o && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["pageSize"]); void 0 !== e && null != i && l(e, ["_query", "pageSize"], i); const s = r(t, ["pageToken"]); void 0 !== e && null != s && l(e, ["_query", "pageToken"], s); return o }(0, o, e)); return e }(this.apiClient, c), i = s("cachedContents", a._url), delete a.config, o = this.apiClient.get(i, a, ln, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["nextPageToken"]); null != o && l(e, ["nextPageToken"], o); const i = r(t, ["cachedContents"]); null != i && l(e, ["cachedContents"], i.map((t => st(n, t)))); return e }(this.apiClient, n); let e = new ln; return Object.assign(e, t), e }))) : (a = function (n, t) { const e = {}, o = r(t, ["config"]); null != o && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["pageSize"]); void 0 !== e && null != i && l(e, ["_query", "pageSize"], i); const s = r(t, ["pageToken"]); void 0 !== e && null != s && l(e, ["_query", "pageToken"], s); return o }(0, o, e)); return e }(this.apiClient, c), i = s("cachedContents", a._url), delete a.config, o = this.apiClient.get(i, a, ln, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["nextPageToken"]); null != o && l(e, ["nextPageToken"], o); const i = r(t, ["cachedContents"]); null != i && l(e, ["cachedContents"], i.map((t => it(n, t)))); return e }(this.apiClient, n); let e = new ln; return Object.assign(e, t), e }))) } } function Xn(n, t, e) { const o = {}, i = r(t, ["parts"]); null != i && l(o, ["parts"], i.map((n => function (n, t) { const e = {}; if (void 0 !== r(t, ["videoMetadata"])) throw new Error("videoMetadata parameter is not supported in Gemini API."); const o = r(t, ["thought"]); null != o && l(e, ["thought"], o); const i = r(t, ["codeExecutionResult"]); null != i && l(e, ["codeExecutionResult"], i); const s = r(t, ["executableCode"]); null != s && l(e, ["executableCode"], s); const a = r(t, ["fileData"]); null != a && l(e, ["fileData"], a); const c = r(t, ["functionCall"]); null != c && l(e, ["functionCall"], c); const u = r(t, ["functionResponse"]); null != u && l(e, ["functionResponse"], u); const p = r(t, ["inlineData"]); null != p && l(e, ["inlineData"], p); const d = r(t, ["text"]); return null != d && l(e, ["text"], d), e }(0, n)))); const s = r(t, ["role"]); return null != s && l(o, ["role"], s), o } function Zn(n, t, e) { const o = {}, i = r(t, ["parts"]); null != i && l(o, ["parts"], i.map((n => function (n, t) { const e = {}, o = r(t, ["videoMetadata"]); null != o && l(e, ["videoMetadata"], o); const i = r(t, ["thought"]); null != i && l(e, ["thought"], i); const s = r(t, ["codeExecutionResult"]); null != s && l(e, ["codeExecutionResult"], s); const a = r(t, ["executableCode"]); null != a && l(e, ["executableCode"], a); const c = r(t, ["fileData"]); null != c && l(e, ["fileData"], c); const u = r(t, ["functionCall"]); null != u && l(e, ["functionCall"], u); const p = r(t, ["functionResponse"]); null != p && l(e, ["functionResponse"], p); const d = r(t, ["inlineData"]); null != d && l(e, ["inlineData"], d); const f = r(t, ["text"]); return null != f && l(e, ["text"], f), e }(0, n)))); const s = r(t, ["role"]); return null != s && l(o, ["role"], s), o } function Qn(n, t, e) { const o = {}, i = r(t, ["response"]); null != i && l(o, ["response"], function (n, t) { const e = {}, o = r(t, ["minItems"]); null != o && l(e, ["minItems"], o); const i = r(t, ["example"]); null != i && l(e, ["example"], i); const s = r(t, ["propertyOrdering"]); null != s && l(e, ["propertyOrdering"], s); const a = r(t, ["pattern"]); null != a && l(e, ["pattern"], a); const c = r(t, ["minimum"]); null != c && l(e, ["minimum"], c); const u = r(t, ["default"]); null != u && l(e, ["default"], u); const p = r(t, ["anyOf"]); null != p && l(e, ["anyOf"], p); const d = r(t, ["maxLength"]); null != d && l(e, ["maxLength"], d); const f = r(t, ["title"]); null != f && l(e, ["title"], f); const m = r(t, ["minLength"]); null != m && l(e, ["minLength"], m); const h = r(t, ["minProperties"]); null != h && l(e, ["minProperties"], h); const g = r(t, ["maxItems"]); null != g && l(e, ["maxItems"], g); const E = r(t, ["maximum"]); null != E && l(e, ["maximum"], E); const C = r(t, ["nullable"]); null != C && l(e, ["nullable"], C); const v = r(t, ["maxProperties"]); null != v && l(e, ["maxProperties"], v); const I = r(t, ["type"]); null != I && l(e, ["type"], I); const O = r(t, ["description"]); null != O && l(e, ["description"], O); const T = r(t, ["enum"]); null != T && l(e, ["enum"], T); const _ = r(t, ["format"]); null != _ && l(e, ["format"], _); const A = r(t, ["items"]); null != A && l(e, ["items"], A); const y = r(t, ["properties"]); null != y && l(e, ["properties"], y); const S = r(t, ["required"]); return null != S && l(e, ["required"], S), e }(0, i)); const s = r(t, ["description"]); null != s && l(o, ["description"], s); const a = r(t, ["name"]); null != a && l(o, ["name"], a); const c = r(t, ["parameters"]); return null != c && l(o, ["parameters"], c), o } function nt(n, t, e) { const o = {}, i = r(t, ["dynamicRetrievalConfig"]); return null != i && l(o, ["dynamicRetrievalConfig"], function (n, t) { const e = {}, o = r(t, ["mode"]); null != o && l(e, ["mode"], o); const i = r(t, ["dynamicThreshold"]); return null != i && l(e, ["dynamicThreshold"], i), e }(0, i)), o } function tt(n, t, e) { const o = {}, i = r(t, ["dynamicRetrievalConfig"]); return null != i && l(o, ["dynamicRetrievalConfig"], function (n, t) { const e = {}, o = r(t, ["mode"]); null != o && l(e, ["mode"], o); const i = r(t, ["dynamicThreshold"]); return null != i && l(e, ["dynamicThreshold"], i), e }(0, i)), o } function et(n, t, e) { const o = {}, i = r(t, ["functionDeclarations"]); if (null != i && l(o, ["functionDeclarations"], i.map((n => function (n, t) { const e = {}; if (void 0 !== r(t, ["response"])) throw new Error("response parameter is not supported in Gemini API."); const o = r(t, ["description"]); null != o && l(e, ["description"], o); const i = r(t, ["name"]); null != i && l(e, ["name"], i); const s = r(t, ["parameters"]); return null != s && l(e, ["parameters"], s), e }(0, n)))), void 0 !== r(t, ["retrieval"])) throw new Error("retrieval parameter is not supported in Gemini API."); const s = r(t, ["googleSearch"]); null != s && l(o, ["googleSearch"], {}); const a = r(t, ["googleSearchRetrieval"]); null != a && l(o, ["googleSearchRetrieval"], nt(0, a)); const c = r(t, ["codeExecution"]); return null != c && l(o, ["codeExecution"], c), o } function ot(n, t, e) { const o = {}, i = r(t, ["functionDeclarations"]); null != i && l(o, ["functionDeclarations"], i.map((n => Qn(0, n)))); const s = r(t, ["retrieval"]); null != s && l(o, ["retrieval"], s); const a = r(t, ["googleSearch"]); null != a && l(o, ["googleSearch"], {}); const c = r(t, ["googleSearchRetrieval"]); null != c && l(o, ["googleSearchRetrieval"], tt(0, c)); const u = r(t, ["codeExecution"]); return null != u && l(o, ["codeExecution"], u), o } function it(n, t, e) { const o = {}, i = r(t, ["name"]); null != i && l(o, ["name"], i); const s = r(t, ["displayName"]); null != s && l(o, ["displayName"], s); const a = r(t, ["model"]); null != a && l(o, ["model"], a); const c = r(t, ["createTime"]); null != c && l(o, ["createTime"], c); const u = r(t, ["updateTime"]); null != u && l(o, ["updateTime"], u); const p = r(t, ["expireTime"]); null != p && l(o, ["expireTime"], p); const d = r(t, ["usageMetadata"]); return null != d && l(o, ["usageMetadata"], d), o } function st(n, t, e) { const o = {}, i = r(t, ["name"]); null != i && l(o, ["name"], i); const s = r(t, ["displayName"]); null != s && l(o, ["displayName"], s); const a = r(t, ["model"]); null != a && l(o, ["model"], a); const c = r(t, ["createTime"]); null != c && l(o, ["createTime"], c); const u = r(t, ["updateTime"]); null != u && l(o, ["updateTime"], u); const p = r(t, ["expireTime"]); null != p && l(o, ["expireTime"], p); const d = r(t, ["usageMetadata"]); return null != d && l(o, ["usageMetadata"], d), o } function lt(n) { var t; if (null == n.candidates || 0 === n.candidates.length) return !1; const e = null === (t = n.candidates[0]) || void 0 === t ? void 0 : t.content; if (void 0 === e) return !1; if (void 0 === e.parts || 0 === e.parts.length) return !1; for (const n of e.parts) { if (void 0 === n || 0 === Object.keys(n).length) return !1; if (void 0 !== n.text && "" === n.text) return !1 } return !0 } class rt { constructor(n, t) { this.modelsModule = n, this.apiClient = t } create(n, t = {}, e = []) { return new at(this.apiClient, this.modelsModule, n, t, e) } } class at { constructor(n, t, e, o, i) { this.apiClient = n, this.modelsModule = t, this.model = e, this.config = o, this.curatedHistory = i, this.sendPromise = Promise.resolve() } async sendMessage(n) { await this.sendPromise; const t = d(this.apiClient, n), e = this.modelsModule.generateContent({ model: this.model, contents: this.curatedHistory.concat(t), config: this.config }); return this.sendPromise = (async () => { var n, o; const i = await e; if (lt(i)) { this.curatedHistory.push(t); const e = null === (o = null === (n = null == i ? void 0 : i.candidates) || void 0 === n ? void 0 : n[0]) || void 0 === o ? void 0 : o.content; void 0 !== e && this.curatedHistory.push(e) } })(), await this.sendPromise, e } async sendMessageStream(n) { await this.sendPromise; const i = d(this.apiClient, n), s = this.modelsModule.generateContentStream({ model: this.model, contents: this.curatedHistory.concat(i), config: this.config }); this.sendPromise = s.then((() => { })); const l = function (n, i, s) { var l, r, a, c; return e(this, arguments, (function* () { var e, u, p, d; const f = []; let m; try { for (var h, g = !0, E = o(n); !(e = (h = yield t(E.next())).done); g = !0) { d = h.value, g = !1; const n = d; if (lt(n)) { const t = null === (r = null === (l = null == n ? void 0 : n.candidates) || void 0 === l ? void 0 : l[0]) || void 0 === r ? void 0 : r.content; void 0 !== t && f.push(t), void 0 !== (null === (c = null === (a = null == n ? void 0 : n.candidates) || void 0 === a ? void 0 : a[0]) || void 0 === c ? void 0 : c.finishReason) && (m = n.candidates[0].finishReason) } f.length && void 0 !== m && (i.push(s), i.push(...f)), yield yield t(n) } } catch (n) { u = { error: n } } finally { try { g || e || !(p = E.return) || (yield t(p.call(E))) } finally { if (u) throw u.error } } })) }(await s, this.curatedHistory, i); return l } } class ct extends i { constructor(n) { super(), this.apiClient = n, this.list = async (n = {}) => new Wn(qn.PAGED_ITEM_FILES, this.listInternal, await this.listInternal(n), n.config) } async listInternal(n) { var t, e; let o, i = "", a = {}; const c = {}; return c.config = n.config, this.apiClient.isVertexAI() ? (a = function (n, t) { const e = {}; if (void 0 !== r(t, ["config"])) throw new Error("config parameter is not supported in Vertex AI."); return e }(this.apiClient, c), i = s("None", a._url), delete a.config, o = this.apiClient.get(i, a, rn, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => { const t = (this.apiClient, {}); let e = new rn; return Object.assign(e, t), e }))) : (a = function (n, t) { const e = {}, o = r(t, ["config"]); null != o && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["pageSize"]); void 0 !== e && null != i && l(e, ["_query", "pageSize"], i); const s = r(t, ["pageToken"]); void 0 !== e && null != s && l(e, ["_query", "pageToken"], s); return o }(0, o, e)); return e }(this.apiClient, c), i = s("files", a._url), delete a.config, o = this.apiClient.get(i, a, rn, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["nextPageToken"]); null != o && l(e, ["nextPageToken"], o); const i = r(t, ["files"]); null != i && l(e, ["files"], i.map((t => ut(n, t)))); return e }(this.apiClient, n); let e = new rn; return Object.assign(e, t), e }))) } async get(n) { var t, e; let o, i = "", a = {}; const c = {}; return c.name = n.name, c.config = n.config, this.apiClient.isVertexAI() ? (a = function (n, t) { const e = {}; if (void 0 !== r(t, ["name"])) throw new Error("name parameter is not supported in Vertex AI."); if (void 0 !== r(t, ["config"])) throw new Error("config parameter is not supported in Vertex AI."); return e }(this.apiClient, c), i = s("None", a._url), delete a.config, o = this.apiClient.get(i, a, void 0, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => (this.apiClient, {})))) : (a = function (n, t) { const e = {}, o = r(t, ["name"]); null != o && l(e, ["_url", "file"], function (n, t) { return t.startsWith("files/") ? t.split("files/")[1] : t }(0, o)); const i = r(t, ["config"]); null != i && l(e, ["config"], i); return e }(this.apiClient, c), i = s("files/{file}", a._url), delete a.config, o = this.apiClient.get(i, a, void 0, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => ut(this.apiClient, n)))) } } function ut(n, t, e) { const o = {}, i = r(t, ["name"]); null != i && l(o, ["name"], i); const s = r(t, ["displayName"]); null != s && l(o, ["displayName"], s); const a = r(t, ["mimeType"]); null != a && l(o, ["mimeType"], a); const c = r(t, ["sizeBytes"]); null != c && l(o, ["sizeBytes"], c); const u = r(t, ["createTime"]); null != u && l(o, ["createTime"], u); const p = r(t, ["expirationTime"]); null != p && l(o, ["expirationTime"], p); const d = r(t, ["updateTime"]); null != d && l(o, ["updateTime"], d); const f = r(t, ["sha256Hash"]); null != f && l(o, ["sha256Hash"], f); const m = r(t, ["uri"]); null != m && l(o, ["uri"], m); const h = r(t, ["downloadUri"]); null != h && l(o, ["downloadUri"], h); const g = r(t, ["state"]); null != g && l(o, ["state"], g); const E = r(t, ["source"]); null != E && l(o, ["source"], E); const C = r(t, ["videoMetadata"]); null != C && l(o, ["videoMetadata"], C); const v = r(t, ["error"]); return null != v && l(o, ["error"], function (n, t) { const e = {}, o = r(t, ["details"]); null != o && l(e, ["details"], o); const i = r(t, ["message"]); null != i && l(e, ["message"], i); const s = r(t, ["code"]); return null != s && l(e, ["code"], s), e }(0, v)), o } const pt = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI."; function dt(n, t, e) { let o = {}, i = r(t, ["config"]); void 0 !== i && l(o, ["setup"], function (n, t) { let e = {}, o = r(t, ["generationConfig"]); void 0 !== o && l(e, ["generationConfig"], o); let i = r(t, ["responseModalities"]); void 0 !== i && l(e, ["generationConfig", "responseModalities"], i); let s = r(t, ["speechConfig"]); void 0 !== s && l(e, ["generationConfig", "speechConfig"], s); let a = r(t, ["systemInstruction"]); void 0 !== a && l(e, ["systemInstruction"], vn(0, a)); let c = r(t, ["tools"]); return void 0 !== c && l(e, ["tools"], c.map((n => An(0, n)))), e }(0, i)); let s = r(t, ["model"]); return void 0 !== s && l(o, ["setup", "model"], s), o } function ft(n, t, e) { let o = {}, i = r(t, ["config"]); void 0 !== i && l(o, ["setup"], function (n, t) { let e = {}, o = r(t, ["generationConfig"]); void 0 !== o && l(e, ["generationConfig"], o); let i = r(t, ["responseModalities"]); l(e, ["generationConfig", "responseModalities"], void 0 !== i ? i : ["AUDIO"]); let s = r(t, ["speechConfig"]); void 0 !== s && l(e, ["generationConfig", "speechConfig"], s); let a = r(t, ["systemInstruction"]); void 0 !== a && l(e, ["systemInstruction"], In(0, a)); let c = r(t, ["tools"]); return void 0 !== c && l(e, ["tools"], c.map((n => yn(0, n)))), e }(0, i)); let s = r(t, ["model"]); return void 0 !== s && l(o, ["setup", "model"], s), o } function mt(n, t, e) { let o = {}, i = r(t, ["functionCalls"]); return void 0 !== i && l(o, ["functionCalls"], i.map((n => function (n, t) { let e = {}, o = r(t, ["id"]); void 0 !== o && l(e, ["id"], o); let i = r(t, ["args"]); void 0 !== i && l(e, ["args"], i); let s = r(t, ["name"]); return void 0 !== s && l(e, ["name"], s), e }(0, n)))), o } function ht(n, t, e) { let o = {}, i = r(t, ["functionCalls"]); return void 0 !== i && l(o, ["functionCalls"], i.map((n => function (n, t) { let e = {}, o = r(t, ["args"]); void 0 !== o && l(e, ["args"], o); let i = r(t, ["name"]); return void 0 !== i && l(e, ["name"], i), e }(0, n)))), o } function gt(n, t, e) { let o = {}; void 0 !== r(t, ["setupComplete"]) && l(o, ["setupComplete"], {}); let i = r(t, ["serverContent"]); void 0 !== i && l(o, ["serverContent"], function (n, t) { let e = {}, o = r(t, ["modelTurn"]); void 0 !== o && l(e, ["modelTurn"], bn(0, o)); let i = r(t, ["turnComplete"]); void 0 !== i && l(e, ["turnComplete"], i); let s = r(t, ["interrupted"]); return void 0 !== s && l(e, ["interrupted"], s), e }(0, i)); let s = r(t, ["toolCall"]); void 0 !== s && l(o, ["toolCall"], mt(0, s)); let a = r(t, ["toolCallCancellation"]); return void 0 !== a && l(o, ["toolCallCancellation"], function (n, t) { let e = {}, o = r(t, ["ids"]); return void 0 !== o && l(e, ["ids"], o), e }(0, a)), o } function Et(n, t, e) { let o = {}; void 0 !== r(t, ["setupComplete"]) && l(o, ["setupComplete"], {}); let i = r(t, ["serverContent"]); void 0 !== i && l(o, ["serverContent"], function (n, t) { let e = {}, o = r(t, ["modelTurn"]); void 0 !== o && l(e, ["modelTurn"], Ln(0, o)); let i = r(t, ["turnComplete"]); void 0 !== i && l(e, ["turnComplete"], i); let s = r(t, ["interrupted"]); return void 0 !== s && l(e, ["interrupted"], s), e }(0, i)); let s = r(t, ["toolCall"]); void 0 !== s && l(o, ["toolCall"], ht(0, s)); let a = r(t, ["toolCallCancellation"]); return void 0 !== a && l(o, ["toolCallCancellation"], function (n, t) { let e = {}, o = r(t, ["ids"]); return void 0 !== o && l(e, ["ids"], o), e }(0, a)), o } class Ct { constructor(n, t, e) { this.apiClient = n, this.auth = t, this.webSocketFactory = e } async connect(n, t, e) { var o, i, s; const l = this.apiClient.getWebsocketBaseUrl(), r = this.apiClient.getApiVersion(); let c, u, p = new Headers; if (p.append("Content-Type", "application/json"), this.apiClient.isVertexAI()) c = `${l}/ws/google.cloud.aiplatform.${r}.LlmBidiService/BidiGenerateContent`, await this.auth.addAuthHeaders(p); else { c = `${l}/ws/google.ai.generativelanguage.${r}.GenerativeService.BidiGenerateContent?key=${this.apiClient.getApiKey()}` } const d = new Promise((n => { u = n })), f = { onopen: function () { var n; null === (n = null == e ? void 0 : e.onopen) || void 0 === n || n.call(e), u() }, onmessage: null !== (o = null == e ? void 0 : e.onmessage) && void 0 !== o ? o : function (n) { }, onerror: null !== (i = null == e ? void 0 : e.onerror) && void 0 !== i ? i : function (n) { }, onclose: null !== (s = null == e ? void 0 : e.onclose) && void 0 !== s ? s : function (n) { } }, m = this.webSocketFactory.create(c, function (n) { let t = {}; return n.forEach(((n, e) => { t[e] = n })), t }(p), f); m.connect(), await d; let h = a(this.apiClient, n); if (this.apiClient.isVertexAI() && h.startsWith("publishers/")) { h = `projects/${this.apiClient.getProject()}/locations/${this.apiClient.getLocation()}/` + h } let g = {}, E = {}; return E.model = h, E.config = t, g = this.apiClient.isVertexAI() ? ft(this.apiClient, E) : dt(this.apiClient, E), m.send(JSON.stringify(g)), new vt(m, this.apiClient) } } class vt { constructor(n, t) { this.conn = n, this.apiClient = t } parseClientMessage(n, t, e = !1) { if ("object" == typeof t && null !== t && "setup" in t) throw new Error("Message type 'setup' is not supported in send(). Use connect() instead."); if ("string" == typeof t) t = [t]; else if ("object" == typeof t && null !== t && "name" in t && "response" in t) { if (!n.isVertexAI() && !("id" in t)) throw new Error(pt); t = [t] } let o = t; if (Array.isArray(t) && t.some((n => "object" == typeof n && null !== n && "name" in n && "response" in n))) o = { toolResponse: { functionResponses: t } }; else if (Array.isArray(t) && t.some((n => "string" == typeof n))) { o = { clientContent: { turns: n.isVertexAI() ? m(0, t).map((n => In(0, n))) : m(0, t).map((n => vn(0, n))), turnComplete: e } } } else if ("object" == typeof t && null !== t && "content" in t) o = { clientContent: t }; else if ("object" == typeof t && null !== t && "mediaChunks" in t) o = { realtimeInput: t }; else if ("object" == typeof t && null !== t && "turns" in t) o = { clientContent: t }; else if ("object" == typeof t && null !== t && "functionResponses" in t) { if (!n.isVertexAI() && !t.functionResponses[0].id) throw new Error(pt); o = { toolResponse: t } } else if ("object" == typeof t && null !== t && "name" in t && "response" in t) { if (!n.isVertexAI() && !t.id) throw new Error(pt); o = { toolResponse: { functionResponses: [t] } } } else { if (!(Array.isArray(t) && "object" == typeof t[0] && null !== t[0] && "name" in t[0] && "response" in t[0])) throw new Error(`Unsupported input type '${typeof t}' or input content '${t}'.`); if (!n.isVertexAI() && !t[0].id) throw new Error(pt); o = { toolResponse: { functionResponses: t.map((n => n)) } } } return o } send(n, t = !1) { const e = this.parseClientMessage(this.apiClient, n, t); this.conn.send(JSON.stringify(e)) } async receive() { return new Promise((n => { this.conn.setOnMessageCallback((async t => { let e = {}; e = this.apiClient.isVertexAI() ? Et(this.apiClient, JSON.parse(typeof t.data === "string" ? t.data : await t.data.text())) : gt(this.apiClient, JSON.parse(typeof t.data === "string" ? t.data : await t.data.text())), n(e) })) })) } close() { this.conn.close() } } class It extends i { constructor(n) { super(), this.apiClient = n, this.get = async n => await this.getInternal(n), this.list = async (n = {}) => new Wn(qn.PAGED_ITEM_TUNING_JOBS, this.listInternal, await this.listInternal(n), n.config) } async getInternal(n) { var t, e; let o, i = "", a = {}; const c = {}; return c.name = n.name, c.config = n.config, this.apiClient.isVertexAI() ? (a = function (n, t) { const e = {}, o = r(t, ["name"]); null != o && l(e, ["_url", "name"], o); const i = r(t, ["config"]); null != i && l(e, ["config"], i); return e }(this.apiClient, c), i = s("{name}", a._url), delete a.config, o = this.apiClient.get(i, a, void 0, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => Tt(this.apiClient, n)))) : (a = function (n, t) { const e = {}, o = r(t, ["name"]); null != o && l(e, ["_url", "name"], o); const i = r(t, ["config"]); null != i && l(e, ["config"], i); return e }(this.apiClient, c), i = s("{name}", a._url), delete a.config, o = this.apiClient.get(i, a, void 0, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => Ot(this.apiClient, n)))) } async listInternal(n) { var t, e; let o, i = "", a = {}; const c = {}; return c.config = n.config, this.apiClient.isVertexAI() ? (a = function (n, t) { const e = {}, o = r(t, ["config"]); null != o && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["pageSize"]); void 0 !== e && null != i && l(e, ["_query", "pageSize"], i); const s = r(t, ["pageToken"]); void 0 !== e && null != s && l(e, ["_query", "pageToken"], s); const a = r(t, ["filter"]); void 0 !== e && null != a && l(e, ["_query", "filter"], a); return o }(0, o, e)); return e }(this.apiClient, c), i = s("tuningJobs", a._url), delete a.config, o = this.apiClient.get(i, a, on, null === (t = n.config) || void 0 === t ? void 0 : t.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["nextPageToken"]); null != o && l(e, ["nextPageToken"], o); const i = r(t, ["tuningJobs"]); null != i && l(e, ["tuningJobs"], i.map((t => Tt(n, t)))); return e }(this.apiClient, n); let e = new on; return Object.assign(e, t), e }))) : (a = function (n, t) { const e = {}, o = r(t, ["config"]); null != o && l(e, ["config"], function (n, t, e) { const o = {}, i = r(t, ["pageSize"]); void 0 !== e && null != i && l(e, ["_query", "pageSize"], i); const s = r(t, ["pageToken"]); void 0 !== e && null != s && l(e, ["_query", "pageToken"], s); const a = r(t, ["filter"]); void 0 !== e && null != a && l(e, ["_query", "filter"], a); return o }(0, o, e)); return e }(this.apiClient, c), i = s("tunedModels", a._url), delete a.config, o = this.apiClient.get(i, a, on, null === (e = n.config) || void 0 === e ? void 0 : e.httpOptions), o.then((n => { const t = function (n, t) { const e = {}, o = r(t, ["nextPageToken"]); null != o && l(e, ["nextPageToken"], o); const i = r(t, ["tunedModels"]); null != i && l(e, ["tuningJobs"], i.map((t => Ot(n, t)))); return e }(this.apiClient, n); let e = new on; return Object.assign(e, t), e }))) } } function Ot(n, t, e) { const o = {}, i = r(t, ["name"]); null != i && l(o, ["name"], i); const s = r(t, ["state"]); null != s && l(o, ["state"], O(0, s)); const a = r(t, ["createTime"]); null != a && l(o, ["createTime"], a); const c = r(t, ["tuningTask", "startTime"]); null != c && l(o, ["startTime"], c); const u = r(t, ["tuningTask", "completeTime"]); null != u && l(o, ["endTime"], u); const p = r(t, ["updateTime"]); null != p && l(o, ["updateTime"], p); const d = r(t, ["description"]); null != d && l(o, ["description"], d); const f = r(t, ["baseModel"]); null != f && l(o, ["baseModel"], f); const m = r(t, ["_self"]); null != m && l(o, ["tunedModel"], function (n, t) { const e = {}, o = r(t, ["name"]); null != o && l(e, ["model"], o); const i = r(t, ["name"]); return null != i && l(e, ["endpoint"], i), e }(0, m)); const h = r(t, ["distillationSpec"]); null != h && l(o, ["distillationSpec"], h); const g = r(t, ["experiment"]); null != g && l(o, ["experiment"], g); const E = r(t, ["labels"]); null != E && l(o, ["labels"], E); const C = r(t, ["pipelineJob"]); null != C && l(o, ["pipelineJob"], C); const v = r(t, ["tunedModelDisplayName"]); return null != v && l(o, ["tunedModelDisplayName"], v), o } function Tt(n, t, e) { const o = {}, i = r(t, ["name"]); null != i && l(o, ["name"], i); const s = r(t, ["state"]); null != s && l(o, ["state"], O(0, s)); const a = r(t, ["createTime"]); null != a && l(o, ["createTime"], a); const c = r(t, ["startTime"]); null != c && l(o, ["startTime"], c); const u = r(t, ["endTime"]); null != u && l(o, ["endTime"], u); const p = r(t, ["updateTime"]); null != p && l(o, ["updateTime"], p); const d = r(t, ["error"]); null != d && l(o, ["error"], d); const f = r(t, ["description"]); null != f && l(o, ["description"], f); const m = r(t, ["baseModel"]); null != m && l(o, ["baseModel"], m); const h = r(t, ["tunedModel"]); null != h && l(o, ["tunedModel"], function (n, t) { const e = {}, o = r(t, ["model"]); null != o && l(e, ["model"], o); const i = r(t, ["endpoint"]); return null != i && l(e, ["endpoint"], i), e }(0, h)); const g = r(t, ["supervisedTuningSpec"]); null != g && l(o, ["supervisedTuningSpec"], g); const E = r(t, ["tuningDataStats"]); null != E && l(o, ["tuningDataStats"], E); const C = r(t, ["encryptionSpec"]); null != C && l(o, ["encryptionSpec"], C); const v = r(t, ["partnerModelTuningSpec"]); null != v && l(o, ["partnerModelTuningSpec"], v); const I = r(t, ["distillationSpec"]); null != I && l(o, ["distillationSpec"], I); const T = r(t, ["experiment"]); null != T && l(o, ["experiment"], T); const _ = r(t, ["labels"]); null != _ && l(o, ["labels"], _); const A = r(t, ["pipelineJob"]); null != A && l(o, ["pipelineJob"], A); const y = r(t, ["tunedModelDisplayName"]); return null != y && l(o, ["tunedModelDisplayName"], y), o } class _t { create(n, t, e) { return new At(n, t, e) } } class At { constructor(n, t, e) { this.url = n, this.headers = t, this.callbacks = e } connect() { this.ws = new WebSocket(this.url), this.ws.onopen = this.callbacks.onopen, this.ws.onerror = this.callbacks.onerror, this.ws.onclose = this.callbacks.onclose, this.ws.onmessage = this.callbacks.onmessage } send(n) { if (void 0 === this.ws) throw new Error("WebSocket is not connected"); this.ws.send(n) } close() { if (void 0 === this.ws) throw new Error("WebSocket is not connected"); this.ws.close() } setOnMessageCallback(n) { if (void 0 === this.ws) throw new Error("WebSocket is not connected"); this.ws.onmessage = n } } class yt { constructor(n) { var t; this.vertexai = null !== (t = n.vertexai) && void 0 !== t && t, this.apiKey = n.apiKey, this.apiVersion = n.apiVersion; const e = new $n(this.apiKey); this.apiClient = new jn({ auth: e, apiVersion: this.apiVersion, apiKey: this.apiKey, vertexai: this.vertexai, httpOptions: n.httpOptions, userAgentExtra: "gl-node/web" }), this.models = new Cn(this.apiClient), this.live = new Ct(this.apiClient, e, new _t), this.tunings = new It(this.apiClient), this.chats = new rt(this.models, this.apiClient), this.caches = new zn(this.apiClient), this.files = new ct(this.apiClient) } } export { L as AdapterSize, M as BlockedReason, zn as Caches, at as Chat, rt as Chats, yt as Client, en as ComputeTokensResponse, $ as ControlReferenceType, tn as CountTokensResponse, sn as DeleteCachedContentResponse, G as DynamicRetrievalConfigMode, Q as EmbedContentResponse, Y as FileSource, j as FileState, N as FinishReason, B as FunctionCallingConfigMode, W as FunctionResponse, Z as GenerateContentResponse, z as GenerateContentResponsePromptFeedback, X as GenerateContentResponseUsageMetadata, nn as GenerateImagesResponse, R as HarmBlockMethod, w as HarmBlockThreshold, S as HarmCategory, P as HarmProbability, x as HarmSeverity, V as ImagePromptLanguage, b as JobState, A as Language, ln as ListCachedContentsResponse, rn as ListFilesResponse, on as ListTuningJobsResponse, Ct as Live, cn as LiveClientToolResponse, J as MaskReferenceMode, H as MediaResolution, K as Modality, D as Mode, Cn as Models, _ as Outcome, k as PersonGeneration, an as ReplayResponse, F as SafetyFilterLevel, vt as Session, U as State, q as SubjectReferenceType, y as Type, Xn as contentToMldev, Zn as contentToVertex, mn as createPartFromBase64, gn as createPartFromCodeExecutionResult, En as createPartFromExecutableCode, dn as createPartFromFunctionCall, fn as createPartFromFunctionResponse, pn as createPartFromText, un as createPartFromUri, hn as createPartFromVideoMetadata, et as toolToMldev, ot as toolToVertex };
//# sourceMappingURL=genai.js.map