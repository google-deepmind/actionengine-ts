{
  "version": 3,
  "sources": ["../interfaces.ts", "../content/index.ts", "../content/mime.ts", "../content/content.ts", "../stream/index.ts", "../stream/stream.ts", "../content/prompt.ts", "../content/audio.ts", "../content/video.ts", "../sessions/index.ts", "../async/index.ts", "../sessions/utils.ts", "../sessions/session.ts", "../sessions/local.ts", "../sessions/middleware/index.ts", "../sessions/middleware/debug.ts", "../actions/index.ts", "../actions/common.ts", "../actions/toy.ts", "../actions/google/index.ts", "../actions/google/genai.ts", "../base64/index.ts", "../actions/drive/index.ts", "../actions/drive/auth.ts", "../actions/drive/drive.ts", "../actions/evergreen/index.ts", "../actions/evergreen/actions.ts", "../actions/evergreen/net.ts", "../actions/evergreen/run.ts"],
  "sourcesContent": ["/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { type StreamItems, type ReadableStream, type WritableStream } from \"./stream/interfaces\";\n\n// Chunk Interfaces Start\n\n/** google.protobuf.Any proto mapping. */\nexport declare interface Any {\n    readonly '@type': string;\n    readonly [key: string]: undefined | null | string | number | boolean | object;\n}\n\n/** Metadata for a chunk. */\nexport declare interface ChunkMetadata {\n    readonly mimetype?: Mimetype;\n    readonly role?: string;\n    readonly captureTime?: Date;\n    readonly experimental?: Any[];\n}\n\n/** Structured mimetype */\nexport interface Mimetype {\n    // Example: 'application/vnd.google.gdm.content+json'\n    readonly type?: string; // 'application'\n    readonly subtype?: string; // 'content'\n    readonly prefix?: string; // 'vnd.google.gdm' the prefix such as vnd\n    readonly suffix?: string; // 'json', from +json suffix\n    readonly parameters?: Record<string, string>; // after the ';' like '; type=aiae.v1.MyConfig' or charset=utf-8\n}\n\n/** Chunk with metadata. */\nexport interface MetadataChunk {\n    readonly metadata?: ChunkMetadata;\n}\n\n/** Chunk with bytes. */\nexport interface DataChunk extends MetadataChunk {\n    readonly data: Uint8Array;\n    readonly ref?: undefined;\n}\n\n/** Chunk with a reference to content elsewhere. */\nexport interface RefChunk extends MetadataChunk {\n    readonly data?: undefined;\n    readonly ref: string;\n}\n\n/** Smallest unit of streamable information. */\nexport type Chunk = DataChunk | RefChunk;\n\n// Chunk Interfaces End\n\n// ChunkStream Interfaces Start\n\nexport type Content<T extends Chunk = Chunk> = StreamItems<T>;\nexport type Input<T extends Chunk = Chunk> = ReadableStream<T>;\nexport type Output<T extends Chunk = Chunk> = WritableStream<T>\nexport interface Pipe<T extends Chunk = Chunk> extends Input<T>, Output<T> {\n}\n\n// ChunkStream Interfaces End\n\n// Action Interfaces Start\n\nexport type Dict<T,U extends string = string> = Readonly<Record<U,T>>;\ntype StreamTypeOfDict<T extends Dict<unknown>> = T extends Dict<infer U> ? U extends WritableStream<infer V> ? V : never : never;\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport abstract class Action<T extends Dict<Input> = Dict<Input>, U extends Dict<Output> = Dict<Output>> {\n    abstract run(session: Session, inputs: T, outputs: U): Promise<void>;\n}\n\nexport type ActionInputs<T extends Action> = T extends Action<infer U> ? U : never;\nexport type ActionOutputs<T extends Action> = T extends Action<never, infer V> ? Dict<ReadableStream<StreamTypeOfDict<V>>, keyof V & string> : never;\nexport type ActionConstraints<T extends Action> = keyof ActionOutputs<T> & string;\n// Action Interfaces End\n\n// Processor Interfaces Start\n\n/** Simplified transform of a unified Chunk stream. */\nexport type Processor<I extends string = string, O extends string = string, T extends Chunk = Chunk, U extends Chunk = Chunk> = (stream: AsyncIterable<[I, T]>) => AsyncGenerator<[O, U]>;\n\n/** Processor Chunks. */\nexport type ProcessorChunks<T extends string = string, U extends Chunk = Chunk> = AsyncIterable<[T, U]>;\n/** Input dict to a processor. */\nexport type ProcessorInputs<T extends Processor> =\n    T extends Processor<infer I, string, infer X>?\n    Record<I, AsyncIterable<X>> :\n    never;\n/** Output dict to a processor. */\n \nexport type ProcessorOutputs<T extends Processor> =\n    T extends Processor<never, infer O, never, infer Y>?\n    Record<O, ReadableStream<Y>> :\n    never;\n// export type ProcessorOutputs<T extends Processor> = T extends Processor<string, infer O, Chunk, infer Y> ?\n//   {[K in O]: ReadableStream<Y>} : \n//   never;\nexport type ProcessorConstraints<T extends Processor> = keyof ProcessorOutputs<T> & string;\n// Processor Interfaces End\n\n// Session Interfaces Start\n\nexport interface Session {\n    // Returns a streaming pipe for reading and writing a stream in the context of the session.\n    // Content will exist and can be read for as long as the session is open.\n    // If content stream is provided when creating the pipe it is equivilent to create, write, and close all in one.\n    createPipe<T extends Chunk>(content?: Content<T>): Pipe<T>;\n    // Runs an action.\n    run<T extends Action, U extends ActionConstraints<T> = ActionConstraints<T>>(action: T, inputs: ActionInputs<T>, outputs: U[]): Pick<ActionOutputs<T>,U>;\n    // Runs a processor which is a convenience form transformed to an Action.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    run<T extends Processor<any, any>,\n                  U extends ProcessorConstraints<T> = ProcessorConstraints<T>>(\n        processor: T, inputs: ProcessorInputs<T>,\n        outputs: U[]): Pick<ProcessorOutputs<T>, U>;\n    // Closes the session and all open streams or running actions.\n    close(): Promise<void>;\n}\n\nexport interface SessionWriteOptions {\n   // Sequence in the stream of the chunk defaults to 0.\n   seq?: number, \n   // Is the stream still being written to defaults to false.\n   continued?: boolean,\n}\n\nexport interface SessionContext {\n    read(id: string): AsyncIterable<Chunk>;\n    write(id: string, chunk: Chunk, options?: SessionWriteOptions): Promise<void>;\n    error(id: string, reason?: string): void;\n    close(): Promise<void>;\n}\n\nexport type SessionContextMiddleware = (context: SessionContext) => SessionContext;\n\nexport type SessionProvider = (...middleware: SessionContextMiddleware[]) => Session;\n\n// Session Interfaces End\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from './content.js';\nexport * from './prompt.js';\nexport * from './audio.js';\nexport * from './video.js';\nexport * from './mime.js';", "/**\n * @fileoverview Utilities for processing content chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Mimetype } from \"../interfaces\";\n\n/**\n * Converts a mimetype to a string.\n */\nexport function stringifyMimetype(mimetype?: Mimetype): string {\n  if (!mimetype) {\n    return 'application/octet-stream';\n  }\n  let result = '';\n  if (!mimetype.type) {\n    return result;\n  }\n  result += mimetype.type;\n  if (!mimetype.subtype) {\n    return result;\n  }\n  result += '/';\n  if (mimetype.prefix) {\n    result += `${mimetype.prefix}.`;\n  }\n  result += mimetype.subtype;\n  if (mimetype.suffix) {\n    result += `+${mimetype.suffix}`;\n  }\n  if (mimetype.parameters) {\n    for (const [key, value] of Object.entries(mimetype.parameters)) {\n      result += `;${key}=${value}`;\n    }\n  }\n  return result;\n}\n\n/**\n * Parses a mimetype from a string.\n */\nexport function parseMimetype(mimetype?: string): Mimetype {\n  if (!mimetype) {\n    return {type: 'application', subtype: 'octet-stream'};\n  }\n  let parameters: Record<string, string> | undefined = undefined;\n  const paramParts = mimetype.split(';');\n  if (paramParts.length > 1) {\n    mimetype = mimetype.substring(0, paramParts[0].length);\n    parameters = {};\n    for (let i = 1; i < paramParts.length; i++) {\n      const [key, value] = paramParts[i].trim().split('=');\n      parameters[key] = value;\n    }\n  }\n  const parts = mimetype.split('/');\n  if (parts.length !== 2) {\n    throw new Error(`Invalid mimetype: ${mimetype}`);\n  }\n  const [type, rest] = parts;\n  let subtype: string | undefined = undefined;\n  let prefix: string | undefined = undefined;\n  let suffix: string | undefined = undefined;\n  const vndSplit = rest.lastIndexOf('.');\n  if (vndSplit >= 0) {\n    prefix = rest.slice(0, vndSplit);\n    subtype = rest.slice(vndSplit + 1);\n  } else {\n    subtype = rest;\n  }\n  const suffixSplit = subtype.indexOf('+');\n  if (suffixSplit >= 0) {\n    suffix = subtype.slice(suffixSplit + 1);\n    subtype = subtype.slice(0, suffixSplit);\n  }\n  return {\n    type,\n    subtype,\n    prefix,\n    suffix,\n    parameters,\n  };\n}\n", "/**\n * @fileoverview Utilities for processing content chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Chunk, RefChunk, DataChunk, ChunkMetadata, Mimetype} from '../interfaces.js';\nimport { stringifyMimetype, parseMimetype } from './mime.js';\n\n/** Role enum definition. */\nexport enum ROLE {\n    USER = 'USER',\n    ASSISTANT = 'ASSISTANT',\n    SYSTEM = 'SYSTEM',\n    CONTEXT = 'CONTEXT',\n}\n/** Role of the chunk as a type. */\nexport declare type Role = `${ROLE}`;\n\n/**\n * Type assertion the chunk is a text.\n */\nexport function isTextChunk(maybeChunk: unknown): maybeChunk is TextChunk {\n  return (maybeChunk as Chunk).metadata?.mimetype?.type === 'text';\n}\n\n/**\n * Type assertion the chunk is a json.\n */\nexport function isJsonChunk(maybeChunk: unknown): maybeChunk is TextChunk {\n  const chunk = maybeChunk as Chunk;\n  const mimetype = chunk.metadata?.mimetype;\n  return mimetype?.type === 'application' && mimetype.subtype === 'json';\n}\n\n/**\n * Type assertion the chunk is a blob.\n */\nexport function isRefChunk(maybeChunk: unknown): maybeChunk is RefChunk {\n  return (maybeChunk as Chunk).ref !== undefined;\n}\n\n/**\n * Type assertion the chunk is data.\n */\nexport function isDataChunk(maybeChunk: unknown): maybeChunk is DataChunk {\n  return (maybeChunk as Chunk).data !== undefined;\n}\n\n/**\n * Type assertion the chunk is a chunk.\n */\nexport function isChunk(maybeChunk: unknown): maybeChunk is Chunk {\n  const c = maybeChunk as Chunk;\n  return !!(c.metadata ?? c.data ?? c.ref);\n}\n\n/**\n * Creates a json chunk.\n */\nexport function jsonChunk(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  json: any,\n  metadata: ChunkMetadata = {},\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  replacer?: (this: any, key: string, value: any) => any,\n): Chunk {\n  const defaultMetadata: ChunkMetadata = {\n    captureTime: new Date(),\n  };\n  return {\n    metadata: {\n      ...defaultMetadata,\n      ...metadata,\n      mimetype: {\n        ...metadata.mimetype,\n        type: 'application',\n        subtype: 'json',\n      },\n    },\n    data: new TextEncoder().encode(JSON.stringify(json, replacer)),\n  };\n}\n\n/**\n * Converts a chunk to json.\n */\nexport function chunkJson(\n  chunk: Chunk,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  reviver?: (this: any, key: string, value: any) => any,\n): unknown {\n  if (isJsonChunk(chunk)) {\n    if (isDataChunk(chunk)) {\n      const text = new TextDecoder().decode(chunk.data);\n      return JSON.parse(text, reviver);\n    }\n    if (chunk.ref) {\n      // TODO(doug): Implement ref chunk.\n      throw new Error('Ref chunk not yet implemented');\n    }\n    return null;\n  }\n  throw new Error('Not a json mimetype for the chunk.');\n}\n\n/**\n * Creates a plain text chunk.\n */\nexport function textChunk(\n  text: string,\n  metadata: ChunkMetadata = {},\n): PlainTextChunk {\n  const defaultMetadata: ChunkMetadata = {\n    captureTime: new Date(),\n  };\n  return {\n    metadata: {\n      ...defaultMetadata,\n      ...metadata,\n      mimetype: {\n        ...metadata.mimetype,\n        type: 'text',\n        subtype: 'plain',\n      },\n    },\n    data: new TextEncoder().encode(text),\n  };\n}\n\n/**\n * Converts a chunk to text.\n */\nexport function chunkText(chunk: Chunk, throwOnError = false): string {\n  if (isTextChunk(chunk)) {\n    if (isDataChunk(chunk)) {\n      const text = new TextDecoder().decode(chunk.data);\n      return text;\n    }\n    if (chunk.ref) {\n      // TODO(doug): Implement ref chunk.\n      throw new Error('Ref chunk not yet implemented');\n    }\n    return '';\n  }\n  if (throwOnError) {\n    throw new Error(`Unsupported chunk type: ${JSON.stringify(chunk)}`);\n  }\n  // Unknown chunk type stringify as best as possible.\n  return JSON.stringify(chunk);\n}\n\n/**\n * Converts a chunk to a blob.\n */\nexport function chunkBlob(chunk: Chunk): Blob {\n  let parts: BlobPart[];\n  if (isDataChunk(chunk)) {\n    parts = [chunk.data];\n  } else {\n    // TODO(doug): Implement ref chunk.\n    throw new Error('Ref chunk not yet implemented');\n  }\n  const blob = new Blob(parts, {\n    type: stringifyMimetype(chunk.metadata?.mimetype),\n  });\n  return blob;\n}\n\n/**\n * Converts a image to a chunk.\n */\nexport async function imageChunk(\n  image: HTMLImageElement,\n  metadata: ChunkMetadata = {},\n): Promise<Chunk> {\n  // Wait for image to load if not already loaded.\n  if (!image.complete) {\n    await new Promise<void>((resolve) => {\n      image.addEventListener(\n        'load',\n        () => {\n          resolve();\n        },\n        {once: true},\n      );\n    });\n  }\n  const canvas = new OffscreenCanvas(image.width, image.height);\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new Error('Failed to get 2d context');\n  }\n  ctx.drawImage(image, 0, 0, image.width, image.height);\n  const blob = await canvas.convertToBlob();\n  return await blobChunk(blob, metadata);\n}\n\n/**\n * Returns a data url from a blob. \n */\nexport function dataUrlFromBlob(blob: Blob): Promise<string> {\n  return new Promise<string>((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = function() {\n      if (typeof reader.result === \"string\") {\n        resolve(reader.result);\n      } else {\n        reject(new Error(`result type ${typeof reader.result}`));\n      }\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(blob);\n  });\n}\n\n/**\n * Converts a audio to a chunk.\n */\nexport async function audioChunk(\n  audio: HTMLAudioElement,\n  metadata: ChunkMetadata = {},\n): Promise<Chunk> {\n  // TODO: Implement via media recorder as an option.\n  // const blob = await captureMediaFromElement(audio, maxDurationMs);\n  // return blobChunk(blob, metadata);\n  return fetchChunk(fetch(audio.src), metadata);\n}\n\n/**\n * Converts a video to a chunk.\n */\nexport async function videoChunk(\n  video: HTMLVideoElement,\n  metadata: ChunkMetadata = {},\n): Promise<Chunk> {\n  // TODO(doug): Implement via media recorder as an option.\n  return fetchChunk(fetch(video.src), metadata);\n}\n\n/**\n * Converts a fetch resource to a chunk.\n */\nexport async function fetchChunk(\n  resp: Promise<Response> | Response,\n  metadata: ChunkMetadata = {},\n): Promise<Chunk> {\n  resp = await Promise.resolve(resp);\n  return blobChunk(await resp.blob(), metadata);\n}\n\n/**\n * Converts a blob to a chunk.\n */\nexport async function blobChunk(\n  blob: Blob,\n  metadata: ChunkMetadata = {},\n): Promise<Chunk> {\n  const defaultMetadata: ChunkMetadata = {\n    captureTime: new Date(),\n  };\n  const mimetype = parseMimetype(blob.type);\n  return {\n    metadata: {\n      ...defaultMetadata,\n      ...metadata,\n      mimetype,\n    },\n    data: new Uint8Array(await blob.arrayBuffer()),\n  };\n}\n\n/**\n * Returns a chunk with the given metadata.\n */\nexport function withMetadata<T extends Chunk>(\n  chunk: T,\n  metadata: ChunkMetadata,\n): T {\n  return {\n    ...chunk,\n    metadata: {\n      ...chunk.metadata,\n      ...metadata,\n    },\n  };\n}\n\n/**\n * Returns true if the mimetype matches the given proto message type.\n */\nexport function isProtoMessage(mimeType: Mimetype, messageType: string) {\n  return (\n    mimeType.type === 'application' &&\n    mimeType.subtype === 'x-protobuf' &&\n    mimeType.parameters?.['type'] === messageType\n  );\n}\n\nexport const JSON_MIME_TYPE = {\n  type: 'application',\n  subtype: 'json',\n} as const satisfies Mimetype;\n\nexport const TEXT_MIME_TYPE = {\n  type: 'text',\n  subtype: 'plain',\n} as const satisfies Mimetype;\n\n/**\n * Type of a plain text chunk.\n */\nexport declare type PlainTextChunk = Chunk & {\n  readonly metadata: {\n    readonly mimetype: {readonly type: 'text'; readonly subtype: 'plain'};\n  };\n};\n\n/**\n * Type of a text chunk.\n */\nexport declare type TextChunk = Chunk & {\n  readonly metadata: {readonly mimetype: {readonly type: 'text'}};\n};\n\n/**\n * Type of a audio chunk.\n */\nexport declare type AudioChunk = Chunk & {\n  readonly metadata: {\n    readonly mimetype: {readonly type: 'audio'};\n  };\n};\n\n/**\n * Type of a image chunk.\n */\nexport declare type ImageChunk = Chunk & {\n  readonly metadata: {\n    readonly mimetype: {readonly type: 'image'};\n  };\n};\n\n/**\n * Type of a video chunk.\n */\nexport declare type VideoChunk = Chunk & {\n  readonly metadata: {\n    readonly mimetype: {readonly type: 'video'};\n  };\n};\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from './interfaces.js';\nexport * from './stream.js';", "/**\n * @fileoverview Library for working with lazy tree like stream of chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Stream as StreamInterface, StreamItems } from './interfaces.js';\n\n// Polyfill for Promise.withResolvers\nif (typeof Promise.withResolvers === 'undefined') {\n  Promise.withResolvers = <T>() => {\n    let resolve;\n    let reject;\n    const promise = new Promise<T>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    return { promise, resolve, reject } as unknown as PromiseWithResolvers<T>;\n  };\n}\n\n/**\n * A writable AsyncIterable.\n */\nclass Stream<T> implements StreamInterface<T> {\n  private closed = false;\n  private readonly children: StreamItems<T>[] = [];\n  private readonly iterators: StreamIterator<T>[] = [];\n  private errorValue: string | undefined;\n\n  /**\n   * Writes a value to the stream.\n   */\n  write(value: StreamItems<T>): Promise<void> {\n    if (this.closed) {\n      throw new Error('Stream is closed');\n    }\n    this.children.push(value);\n    for (const iterator of [...this.iterators]) {\n      iterator.write(value);\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Write and close.\n   */\n  async writeAndClose(value: StreamItems<T>): Promise<void> {\n    await this.write(value);\n    await this.close();\n  }\n\n  /**\n   * Closes the stream.\n   */\n  close(): Promise<void> {\n    this.closed = true;\n    for (const iterator of [...this.iterators]) {\n      iterator.close();\n    }\n    return Promise.resolve();\n  }\n\n  get isClosed() {\n    return this.closed;\n  }\n\n  get size() {\n    return this.children.length;\n  }\n\n  get items() {\n    return [...this.children];\n  }\n\n  getError() {\n    return this.errorValue;\n  }\n\n  /*\n   * Errors the stream if there has been a problem.\n   */\n  error(reason?: string) {\n    this.errorValue = reason;\n    this.closed = true;\n    for (const iterator of [...this.iterators]) {\n      iterator.error(reason);\n    }\n  }\n\n  /**\n   * Async iterator over the raw StreamItems being pushed in.\n   */\n  rawAsyncIterator(): AsyncIterator<StreamItems<T>> {\n    const iterator = new StreamIterator(this, this.children, () => {\n      const index = this.iterators.indexOf(iterator);\n      if (index >= 0) {\n        this.iterators.splice(index, 1);\n      }\n    });\n    this.iterators.push(iterator);\n    return iterator;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    const iter = this.rawAsyncIterator();\n    const stream = iteratorToIterable(iter);\n    const chunks = (async function * () {\n      try {\n        yield* leaves(stream);\n      } finally {\n        // Need to explicitly release this iterator memory.\n        if (iter.return) {\n          void iter.return();\n        }\n      }\n    })();\n    return chunks[Symbol.asyncIterator]();\n  }\n\n  then = thenableAsyncIterable;\n}\n\nasync function*\n  iteratorToIterable<T>(iter: AsyncIterator<T>): AsyncIterable<T> {\n  while (true) {\n    const result = await iter.next();\n    if (result.done) break;\n    yield result.value;\n  }\n}\n\nclass StreamIterator<T> implements AsyncIterator<StreamItems<T>> {\n  private readonly writeQueue: StreamItems<T>[] = [];\n  private readonly readQueue:\n    PromiseWithResolvers<IteratorResult<StreamItems<T>>>[] = [];\n\n  constructor(\n    private readonly stream: Stream<T>,\n    current: StreamItems<T>[],\n    private readonly done: () => void,\n  ) {\n    this.writeQueue = [...current];\n  }\n\n  write(value: StreamItems<T>): void {\n    const queued = this.readQueue.shift();\n    if (queued) {\n      queued.resolve({ done: false, value });\n    } else {\n      this.writeQueue.push(value);\n    }\n  }\n\n  close() {\n    const queued = this.readQueue.shift();\n    if (queued) {\n      queued.resolve({ done: true, value: undefined });\n    }\n  }\n\n  error(error?: string) {\n    const queued = this.readQueue.shift();\n    if (queued) {\n      queued.reject(error);\n    }\n  }\n\n  next(): Promise<IteratorResult<StreamItems<T>>> {\n    const value = this.writeQueue.shift();\n    if (value) {\n      return Promise.resolve({ done: false, value });\n    }\n    if (this.stream.getError() !== undefined) {\n      return Promise.reject(new Error(this.stream.getError()));\n    }\n    const done = this.writeQueue.length === 0 && this.stream.isClosed;\n    if (done) {\n      this.done();\n      return Promise.resolve({ done, value: undefined });\n    }\n    const next = Promise.withResolvers<IteratorResult<StreamItems<T>>>();\n    this.readQueue.push(next);\n    return next.promise;\n  }\n\n  return(value?: T): Promise<IteratorResult<StreamItems<T>>> {\n    this.done();\n    return Promise.resolve({ done: true, value });\n  }\n}\n\n/** Constructor function for creating a stream object. */\nexport function createStream<T>(): StreamInterface<T> {\n  return new Stream<T>();\n}\n\n\n/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * implementing a `Symbol.asyncIterator` method.\n */\nexport function isAsyncIterable<T = unknown>(\n  maybeAsyncIterable: unknown,\n): maybeAsyncIterable is AsyncIterable<T> {\n  const iter = maybeAsyncIterable as AsyncIterable<T>;\n  return typeof iter[Symbol.asyncIterator] === 'function';\n}\n\n\n/**\n * Leaves of a Stream because the stream can be recursive this flattens it in\n * order.\n */\nasync function* leaves<T>(items: StreamItems<T>): AsyncIterable<T> {\n  if (items instanceof Array) {\n    for (const node of items) {\n      yield* leaves(node);\n    }\n  } else if (isAsyncIterable<StreamItems<T>>(items)) {\n    for await (const node of items) {\n      yield* leaves(node);\n    }\n  } else {\n    yield items;\n  }\n}\n\n/** A function to aggregate an AsyncIterable to a PromiseLike thenable. */\nexport function thenableAsyncIterable<T, TResult1 = T[], TResult2 = never>(\n  this: AsyncIterable<T>,\n  onfulfilled?: | ((value: T[]) => TResult1 | PromiseLike<TResult1>)   |\n    null,\n  onrejected?: | ((reason: unknown) => TResult2 | PromiseLike<TResult2>) \n     | null,\n): Promise<TResult1 | TResult2> {\n  const aggregate = async () => {\n    const items = [];\n    for await (const item of this) {\n      items.push(item);\n    }\n    return items;\n  };\n  return aggregate().then(onfulfilled, onrejected);\n}\n\n/** Make an asyncIterable PromiseLike. */\nexport function awaitableAsyncIterable<T>(iter: AsyncIterable<T>):\n  AsyncIterable<T> & PromiseLike<T[]> {\n  const then = iter as AsyncIterable<T> & PromiseLike<T[]>;\n  then.then = thenableAsyncIterable;\n  return then;\n}\n", "/**\n * @fileoverview Library for working with lazy tree like stream of chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Chunk, ChunkMetadata, Content } from '../interfaces.js';\nimport { createStream, isAsyncIterable, StreamItems } from '../stream/index.js';\n\nimport { audioChunk, blobChunk, fetchChunk, ROLE, imageChunk, isChunk, textChunk, videoChunk, withMetadata, } from './content.js';\n\n/** Transform a series of unknown values to chunks with the exception of str. */\nfunction transformToContent(\n  value: unknown,\n  metadataFn?: (chunk: Chunk) => ChunkMetadata,\n): Content {\n  if (typeof window !== 'undefined') {\n    if (value instanceof HTMLImageElement) {\n      value = imageChunk(value);\n    } else if (value instanceof HTMLAudioElement) {\n      value = audioChunk(value);\n    } else if (value instanceof HTMLVideoElement) {\n      value = videoChunk(value);\n    }\n  }\n  if (typeof value === 'string') {\n    value = textChunk(value);\n  }\n  if (value instanceof Blob) {\n    value = blobChunk(value);\n  }\n  if (value instanceof Response) {\n    value = fetchChunk(value);\n  }\n  if (isChunk(value)) {\n    if (metadataFn) {\n      value = withMetadata(value, metadataFn(value));\n    }\n  }\n  if (value instanceof Promise) {\n    const pl = createStream<Chunk>();\n    value\n      .then(async (v) => {\n        if (isChunk(v)) {\n          if (metadataFn) {\n            v = withMetadata(v, metadataFn(v));\n          }\n        } else {\n          v = transformToContent(v, metadataFn);\n        }\n        await pl.write(v as StreamItems<Chunk>);\n        await pl.close();\n      })\n      .catch((err: unknown) => {\n        pl.error(`${err}`);\n      });\n    value = pl;\n  }\n  if (!assertIsContent(value)) {\n    throw new Error('Unsupported value type');\n  }\n  return value;\n}\n\n/**\n * Factory for a template literal for constructing a prompt with specific\n * metadata.\n */\nexport function promptLiteralWithMetadata(\n  metadataFn?: (chunk: Chunk) => ChunkMetadata,\n) {\n  function prompt(\n    strings: TemplateStringsArray, ...values: unknown[]): Content {\n    const node: Content[] = [];\n    const l = values.length;\n    let str = '';\n    for (let i = 0; i < l; i++) {\n      str += strings[i];\n      let value = values[i];\n      // Empty values are treated as empty strings.\n      value ??= '';\n      if (typeof value === 'string') {\n        str += value;\n      } else {\n        if (str) {\n          let chunk = textChunk(str);\n          if (metadataFn) {\n            chunk = withMetadata(chunk, metadataFn(chunk));\n          }\n          node.push(chunk);\n        }\n        str = '';\n        node.push(transformToContent(value, metadataFn));\n      }\n    }\n    str += strings[l];\n    if (str) {\n      let chunk = textChunk(str);\n      if (metadataFn) {\n        chunk = withMetadata(chunk, metadataFn(chunk));\n      }\n      node.push(chunk);\n    }\n\n    if (node.length === 1) {\n      return node[0];\n    }\n    return node;\n  }\n  return prompt;\n}\n\nfunction assertIsContent(value: unknown): value is Content {\n  if (Array.isArray(value)) {\n    return value.every((v) => assertIsContent(v));\n  }\n  if (isChunk(value) || isAsyncIterable(value)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Template literal for constructing a prompt.\n */\nexport const prompt = promptLiteralWithMetadata();\n\n/**\n * Template literal for constructing a prompt but always with user role.\n */\nexport const userPrompt = promptLiteralWithMetadata(() => ({ role: ROLE.USER }));\n/**\n * Template literal for constructing a prompt but always with system role.\n */\nexport const systemPrompt = promptLiteralWithMetadata(() => ({\n  role: ROLE.SYSTEM,\n}));\n/**\n * Template literal for constructing a prompt but always with assistant role.\n */\nexport const assistantPrompt = promptLiteralWithMetadata(() => ({\n  role: ROLE.ASSISTANT,\n}));\n/**\n * Template literal for constructing a prompt but always with context role.\n */\nexport const contextPrompt = promptLiteralWithMetadata(() => ({\n  role: ROLE.CONTEXT,\n}));\n\n/**\n * Transforms a Content to a new Content with the given metadata.\n */\nexport function promptWithMetadata(\n  prompt: Content,\n  metadata: ChunkMetadata,\n): Content {\n  if (isChunk(prompt)) {\n    const chunk = withMetadata(prompt, metadata);\n    return chunk;\n  } else if (prompt instanceof Array) {\n    const list: Content = prompt.map(\n      (child) => promptWithMetadata(child, metadata),\n    );\n    return list;\n  } else if (isAsyncIterable(prompt)) {\n    const pipe = createStream<Chunk>();\n    const source = prompt;\n    const transform = async () => {\n      try {\n        for await (const item of source) {\n          void pipe.write(promptWithMetadata(item, metadata));\n        }\n      } catch (err: unknown) {\n        pipe.error(`${err}`);\n      } finally {\n        await pipe.close();\n      }\n    };\n    void transform();\n    return pipe;\n  }\n  throw new Error(`Unsupported type ${prompt}`);\n}\n", "/**\n * @fileoverview Utilities for processing content chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Chunk } from \"../interfaces\";\nimport { AudioChunk } from \"./content\";\n\n// TODO(doug): Parse sample rate and channels from the generator..\nconst DEFAULT_OUTPUT_SAMPLE_RATE = 24000;\nconst DEFAULT_INPUT_SAMPLE_RATE = 16000;\nconst DEFAULT_NUM_CHANNELS = 1;\n\n\nasync function decodeAudioData(\n    chunk: Chunk,\n    ctx: AudioContext,\n    sampleRate: number,\n    numChannels: number,\n): Promise<AudioBuffer> {\n    const data = chunk.data;\n    if (!data) {\n        throw new Error('Chunk without data.');\n    }\n\n    const buffer = ctx.createBuffer(numChannels, data.length / 2 / numChannels, sampleRate);\n\n    const mimetype = chunk.metadata?.mimetype;\n    if (!mimetype) {\n        throw new Error('Chunk without mimetype.');\n    }\n    if (mimetype.type === 'audio' && mimetype.subtype === 'ogg') {\n        // TODO(doug): Audio ogg processing is not working properly.\n        const blob = new Blob([data.buffer as BlobPart], { type: 'audio/ogg' });\n        const oggBuffer = await ctx.decodeAudioData(await blob.arrayBuffer());\n        for (let i = 0; i < numChannels; i++) {\n            buffer.copyToChannel(oggBuffer.getChannelData(i), i);\n        }\n    } else if (mimetype.type === 'audio' && mimetype.subtype === 'pcm') {\n        const dataInt16 = new Int16Array(data.buffer);\n        const l = dataInt16.length;\n        const dataFloat32 = new Float32Array(l);\n        for (let i = 0; i < l; i++) {\n            dataFloat32[i] = dataInt16[i] / 32768.0;\n        }\n        // Extract interleaved channels\n        if (numChannels === 0) {\n            buffer.copyToChannel(dataFloat32, 0);\n        } else {\n            for (let i = 0; i < numChannels; i++) {\n                const channel = dataFloat32.filter(\n                    (_, index) => index % numChannels === i,\n                );\n                buffer.copyToChannel(channel, i);\n            }\n        }\n    } else {\n        throw new Error(`Unsupported mime type: ${JSON.stringify(mimetype)}`);\n    }\n    return buffer;\n}\n\n/** Converts Audio Chunks to a Media Stream. */\nexport function audioChunksToMediaStream(chunks: AsyncIterable<Chunk>): MediaStream {\n    const sampleRate = DEFAULT_OUTPUT_SAMPLE_RATE;\n    const numChannels = DEFAULT_NUM_CHANNELS;\n\n    const media = new MediaStream();\n\n    function nextContext(currentCtx?: AudioContext): [AudioContext, MediaStreamAudioDestinationNode] {\n        if (currentCtx) {\n            void currentCtx.close();\n        }\n        const nextCtx = new AudioContext({ sampleRate });\n        const nextDest = nextCtx.createMediaStreamDestination();\n        media.getTracks().forEach((t) => {\n            media.removeTrack(t);\n        });\n        nextDest.stream.getTracks().forEach((t) => {\n            media.addTrack(t);\n        });\n        return [nextCtx, nextDest];\n    };\n\n    let [ctx, dest] = nextContext();\n\n    async function read() {\n        try {\n            let nextStartTime = 0;\n            for await (const chunk of chunks) {\n                if (chunk.metadata?.mimetype?.type !== 'audio') {\n                    continue;\n                }\n\n                const mimetypeParameters = chunk.metadata.mimetype.parameters;\n                // Use sample rate from chunk if present.\n                let chunkSampleRate = Number(mimetypeParameters?.['rate']);\n                if (isNaN(chunkSampleRate)) {\n                    chunkSampleRate = sampleRate;\n                }\n\n                // Has been a significant delay in next audio chunk.\n                if (ctx.currentTime > nextStartTime) {\n                    [ctx, dest] = nextContext(ctx);\n                    nextStartTime = ctx.currentTime;\n                }\n\n                let audioBuffer: AudioBuffer;\n                try {\n                    audioBuffer = await decodeAudioData(chunk, ctx, sampleRate, numChannels);\n                } catch (e) {\n                    console.error('Error decoding audio data', e);\n                    continue;\n                }\n                const source = ctx.createBufferSource();\n                source.buffer = audioBuffer;\n                source.connect(dest);\n\n                source.start(nextStartTime);\n                nextStartTime = nextStartTime + audioBuffer.duration;\n            }\n            await ctx.close();\n        } finally {\n            if (ctx.state !== 'closed') {\n                void ctx.close();\n            }\n        }\n    }\n    void read();\n    return media;\n}\n\n/** Converts a Media Stream to audio chunks. */\nexport async function* mediaStreamToAudioChunks(media: MediaStream): AsyncGenerator<AudioChunk> {\n    const sampleRate = DEFAULT_INPUT_SAMPLE_RATE;\n    const ctx = new AudioContext({ sampleRate });\n    const numChannels = DEFAULT_NUM_CHANNELS;\n    const src = ctx.createMediaStreamSource(media);\n    // TODO(doug): Use a worklet processor to convert to int16.\n    const BUFFER_SIZE = 8192; // must be a power of 2 between 256 and 16384\n    // eslint-disable-next-line @typescript-eslint/no-deprecated\n    const processor = ctx.createScriptProcessor(\n        BUFFER_SIZE,\n        numChannels,\n        numChannels,\n    );\n    const queue: AudioChunk[] = [];\n    let resolver: ((value: AudioChunk) => void) | undefined = undefined;\n\n    // eslint-disable-next-line @typescript-eslint/no-deprecated\n    processor.onaudioprocess = (e) => {\n        // Data is float32, from -1 to 1.\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        const data = e.inputBuffer.getChannelData(0);\n        const l = data.length;\n        const int16 = new Int16Array(l);\n        for (let i = 0; i < l; i++) {\n            // convert float32 -1 to 1 to int16 -32768 to 32767\n            int16[i] = data[i] * 32768;\n        }\n        const chunk: AudioChunk = {\n            data: new Uint8Array(int16.buffer),\n            metadata: {\n                mimetype: {\n                    type: 'audio',\n                    subtype: 'pcm',\n                    parameters: { 'rate': `${sampleRate}` },\n                },\n            },\n        };\n        if (resolver) {\n            resolver(chunk);\n            resolver = undefined;\n        } else {\n            queue.push(chunk);\n        }\n    };\n    src.connect(processor);\n    processor.connect(ctx.destination);\n    try {\n        while (true) {\n            if (queue.length > 0) {\n                const result = queue.shift();\n                if (result === undefined) {\n                    continue;\n                }\n                yield result;\n            } else {\n                const result = await new Promise<AudioChunk>((resolve) => {\n                    resolver = resolve;\n                });\n                yield result;\n            }\n            if (!media.active) {\n                break;\n            }\n        }\n    } finally {\n        await ctx.close();\n    }\n}\n", "/**\n * @fileoverview Utilities for processing content chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Chunk } from \"../interfaces.js\";\nimport { dataUrlFromBlob, fetchChunk, ImageChunk } from \"./content.js\";\nimport { stringifyMimetype } from \"./mime.js\";\n\n/** Converts image chunks to a Media Stream. */\nexport function imageChunksToMediaStream(chunks: AsyncIterable<Chunk>, options?: { frameRate?: number }): MediaStream {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    let first = true;\n    async function read() {\n        try {\n            for await (const c of chunks) {\n                if (c.metadata?.mimetype?.type !== 'image') {\n                    continue;\n                }\n                const img = new Image();\n                if (c.data) {\n                    img.src = await dataUrlFromBlob(new Blob([c.data], { type: stringifyMimetype(c.metadata?.mimetype) }));\n                } else {\n                    throw new Error(`Not yet implemented ${JSON.stringify(c)}`)\n                }\n                if (first) {\n                    first = false;\n                    canvas.width = img.width;\n                    canvas.height = img.height;\n                    console.log(canvas.width, canvas.height);\n                }\n                ctx?.drawImage(img, 0, 0);\n            }\n        } finally {\n            stream.getTracks().forEach(track => { track.stop(); });\n        }\n    }\n    void read();\n    const stream = canvas.captureStream(options?.frameRate);\n    return stream;\n}\n\ninterface MediaToImageOptions {\n    frameRate: number;\n    scale: number;\n}\n\nconst mediaToImageOptions: MediaToImageOptions = { frameRate: 1, scale: 0.5 } as const;\n\n/** Converts a Media Stream to image chunks. */\nexport async function* mediaStreamToImageChunks(media: MediaStream, options: Partial<MediaToImageOptions> = {}): AsyncGenerator<ImageChunk> {\n    const opts = { ...mediaToImageOptions, ...options };\n    const video = document.createElement('video');\n    video.srcObject = media;\n    video.autoplay = true;\n    video.muted = true;\n    await video.play();\n\n    const canvas = document.createElement('canvas');\n    canvas.width = video.videoWidth * opts.scale;\n    canvas.height = video.videoHeight * opts.scale;\n    const ctx = canvas.getContext('2d');\n\n    while (true) {\n        if (!media.active) {\n            break;\n        }\n        ctx?.drawImage(video, 0, 0, canvas.width, canvas.height);\n        const dataUrl = canvas.toDataURL('image/jpeg', 1.0);\n        yield (await fetchChunk(fetch(dataUrl))) as ImageChunk;\n        await new Promise((resolve) => {\n            setTimeout(resolve, 1000.0 / opts.frameRate);\n        });\n    }\n}", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./session.js\";\nexport * from \"./local.js\";\nexport * as middleware from \"./middleware/index.js\";\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Returns the first promise to resolve and which index it came from.\n */\nfunction raceWithIndex<T>(promises: Promise<T>[]): Promise<[T, number]> {\n    const {promise, resolve, reject} = Promise.withResolvers<[T, number]>();\n    const l = promises.length;\n    let complete = false;\n    for (let i = 0; i < l; i++) {\n      const p = promises[i];\n      p.then((v) => {\n        if (complete) {\n          return;\n        }\n        complete = true;\n        resolve([v, i]);\n      }).catch((e: unknown) => {\n        if (complete) {\n          return;\n        }\n        complete = true;\n        reject(e);\n      });\n    }\n    return promise;\n  }\n  \n  /**\n   * Races a list of streams returning the first value to resolve from any stream.\n   */\n  export async function* merge<\n    T extends readonly (AsyncIterator<unknown>|AsyncIterable<unknown>)[]>(...arr: [...T]): T[number] {\n    const sources = [...arr].map((p) => {\n      const iter = p as AsyncIterable<unknown>;\n      if (typeof iter[Symbol.asyncIterator] === \"function\") {\n        return iter[Symbol.asyncIterator]();\n      }\n      return p as AsyncIterator<unknown>;\n    });\n    const queue = sources.map((p) => p.next());\n    while (queue.length > 0) {\n      const [result, i] = await raceWithIndex(queue);\n      if (result.done) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        queue.splice(i, 1);\n        sources.splice(i, 1);\n      } else {\n        queue[i] = sources[i].next();\n        yield result.value;\n      }\n    }\n  }\n  ", "/**\n * @fileoverview Internal methods for the SDK.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nlet uniqueIdCounter = 1;\n\n/**\n * Test ony method to reset the unique id counter.\n */\nexport function _resetUniqueId() {\n  uniqueIdCounter = 1;\n}\n\n/**\n * Generates a unique id.\n */\nexport function uniqueId() {\n  return `${uniqueIdCounter++}`;\n}\n", "/**\n * @fileoverview Internal methods for the SDK.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Content, Processor, Dict, Action, Chunk, Pipe, Session as SessionInterface, SessionContext, SessionContextMiddleware, SessionProvider, SessionWriteOptions } from '../interfaces.js';\nimport { isAsyncIterable, thenableAsyncIterable, WritableStream, ReadableStream } from '../stream/index.js';\nimport {merge} from '../async/index.js';\n\nimport { uniqueId } from './utils.js';\n\n\nclass SessionPipe<T extends Chunk> implements Pipe<T> {\n    private readonly id = uniqueId();\n    private seq = 0;\n    private closed = false;\n\n    constructor(private readonly context: SessionContext) { }\n\n    [Symbol.asyncIterator](): AsyncIterator<T> {\n        return (this.context.read(this.id) as AsyncIterable<T>)[Symbol.asyncIterator]();\n    }\n    \n    async writeAndClose(content: Content<T>): Promise<void> {\n        if (content instanceof Array) {\n            const l = content.length;\n            for (let i=0;i<l-1;i++) {\n                await this.write(content[i]);\n            }\n            await this.writeAndClose(content[l-1]);\n        } else if (isAsyncIterable<Content<T>>(content)) {\n            await this.write(content);\n            await this.close();\n        } else {\n            await this.writeChunk(content, false);\n        }\n    }\n\n    async write(content: Content<T>): Promise<void> {\n        if (content instanceof Array) {\n            for (const item of content) {\n                await this.write(item)\n            }\n        } else if (isAsyncIterable<Content>(content)) {\n            for await (const item of content) {\n                await this.write(item);\n            }\n        } else {\n            await this.writeChunk(content, true);\n        }\n    }\n\n    error(reason?: string) {\n        this.context.error(this.id, reason);\n    }\n\n    private async writeChunk(chunk: Chunk, continued: boolean): Promise<void> {\n        const options: SessionWriteOptions = {seq: this.seq, continued}\n        this.seq++;\n        if (!continued) {\n            this.closed = true;\n        }\n        await this.context.write(this.id, chunk, options);\n    }\n\n    async close() {\n        // TODO(dougfritz): Should this close by id in the context?\n        if (this.closed) {\n            console.warn('Already closed.');\n            return;\n        }\n        this.closed = true;\n        const seq = this.seq++;\n        await this.context.write(this.id, emptyChunk, { seq, continued: false });\n    }\n\n    then = thenableAsyncIterable;\n}\n\nconst emptyChunk = {\n  metadata: {},\n  data: new Uint8Array(0)\n};\n\nfunction isAction(maybeAction: unknown): maybeAction is Action {\n    if ((maybeAction as Action).run) {\n        return true;\n    }\n    return false;\n}\n\n/** Session wrapper given a SessionContext. */\nclass Session implements SessionInterface {\n    constructor(private readonly context: SessionContext) { }\n\n    createPipe<T extends Chunk = Chunk>(content?: Content<T>): Pipe<T> {\n        const pipe = new SessionPipe<T>(this.context);\n        if (content) {\n            void pipe.writeAndClose(content);\n        }\n        return pipe;\n    }\n\n    run(\n        actionOrProcessor: Action | Processor, inputs: Dict<ReadableStream<Chunk>>, outputs: string[]): Dict<ReadableStream<Chunk>> {\n        // TODO(dougfritz): Verify that the inputs and outputs are in the current session\n        const outs = Object.fromEntries(outputs.map((k) => [k, this.createPipe()]));\n        // context.\n        if (isAction(actionOrProcessor)) {\n            void actionOrProcessor.run(this, inputs, outs);\n        } else {\n            void writeOutputs(actionOrProcessor(joinInputs(inputs)), outs);\n        }\n        return outs;\n    }\n \n    async close(): Promise<void> {\n        await this.context.close();\n    }\n}\n\n/** Adds the name to each item in the Chunk stream. */\nasync function * withName(name: string, stream: ReadableStream<Chunk>): AsyncGenerator<[string, Chunk]> {\n    for await (const c of stream) {\n        yield [name, c];\n    }\n}\n\n/** Joins the inputs in the dict into an eager stream of chunks with named key. */\nasync function * joinInputs(inputs: Dict<ReadableStream<Chunk>>): AsyncGenerator<[string, Chunk]> {\n    const streams = Object.keys(inputs).map((k) => withName(k, inputs[k]));\n    yield* merge(...streams);\n}\n\n/** Writes the unified stream of outputs to a dict of writable streams. */\nasync function writeOutputs(unified: AsyncIterable<[string, Chunk]>, outputs: Dict<WritableStream<Chunk>>) {\n    for await (const [k,c] of unified) {\n        void outputs[k].write(c);\n    }\n    for (const v of Object.values(outputs)) {\n        await v.close();\n    }\n}\n\n/** Provides a session. */\nexport function sessionProvider(contextProvider: () => SessionContext):\n    SessionProvider {\n    return (...middleware: SessionContextMiddleware[]) => {\n        let c: SessionContext = contextProvider();\n        if (middleware) {\n            for (const m of middleware.reverse()) {\n                c = m(c);\n            }\n        }\n        return new Session(c);\n    }\n}\n", "/**\n * @fileoverview Local session.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Chunk, SessionContext, SessionWriteOptions } from \"../interfaces.js\";\nimport { createStream } from \"../stream/stream.js\";\nimport { Stream } from \"../stream/interfaces.js\";\nimport { sessionProvider } from \"./session.js\";\n\nclass LocalContext implements SessionContext {\n    private nodeMap = new Map<string, Stream<Chunk>>();\n    private sequenceOrder = new Map<string, number>();\n\n    private createStream(id: string) {\n        const pl = createStream<Chunk>();\n        this.nodeMap.set(id, pl);\n        this.sequenceOrder.set(id, -1);\n        return pl;\n    }\n\n    async write(id: string, chunk: Chunk, options?: SessionWriteOptions): Promise<void> {\n        let pl = this.nodeMap.get(id);\n        pl ??= this.createStream(id);\n        const lastSeq = this.sequenceOrder.get(id);\n        if (lastSeq === undefined) {\n            throw new Error(`Sequence not found for ${id}`);\n        }\n        const seq = options?.seq ?? 0;\n        if ((lastSeq + 1) !== seq) {\n            throw new Error(`Out of order sequence writes not yet supported. last seq ${lastSeq}, current seq ${seq}`);\n        }\n        this.sequenceOrder.set(id, seq);\n        // Skip writing empty data and ref as it is just a close signal explicit check.\n        if (chunk.data !== undefined || chunk.ref !== undefined) {\n            await pl.write(chunk);\n        }\n        const continued = options?.continued ?? false;\n        if (!continued) {\n            await pl.close();\n        }\n    }\n    error(id: string, reason?: string) {\n        const pl = this.nodeMap.get(id);\n        if (pl === undefined) {\n            throw new Error(`No such id exists ${id}`);\n        }\n        pl.error(reason);\n    }\n    read(id: string): AsyncIterable<Chunk> {\n        let pl = this.nodeMap.get(id);\n        pl ??= this.createStream(id);\n        return pl;\n    };\n\n    async close(): Promise<void> {\n        for (const stream of this.nodeMap.values()) {\n            await stream.close();\n        }\n        this.nodeMap.clear();\n        this.sequenceOrder.clear();\n    }\n}\n\nexport const local = sessionProvider(() => new LocalContext());\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from './debug.js';\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Chunk, SessionContext, SessionContextMiddleware, SessionWriteOptions } from \"../../interfaces.js\";\nimport { chunkText } from \"../../content/content.js\";\n\nclass DebugContext implements SessionContext {\n    constructor(private readonly context: SessionContext) { }\n    read(id: string): AsyncIterable<Chunk> {\n        async function* readAndLog(context: SessionContext) {\n            for await (const chunk of context.read(id)) {\n                console.log(`Reading from ${id}`, chunkText(chunk));\n                yield chunk;\n            }\n        }\n        return readAndLog(this.context);\n    }\n    async write(id: string, chunk: Chunk, options?: SessionWriteOptions): Promise<void> {\n        console.log(`Writing ${id}`, chunkText(chunk), options?.seq, options?.continued);\n        await this.context.write(id, chunk, options);\n    }\n    error(id: string, reason?: string): void {\n        console.error(reason);\n        this.context.error(id, reason);\n    }\n    async close(): Promise<void> {\n        await this.context.close();\n    }\n\n}\n\nexport const debug: SessionContextMiddleware = (context: SessionContext) => {\n    return new DebugContext(context);\n}", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./common.js\";\nexport * from \"./toy.js\";\nexport * as google from './google/index.js';\nexport * as drive from './drive/index.js';\nexport * as evergreen from './evergreen/index.js';", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Input, Output, Action, Session } from '../interfaces.js';\nimport { type AudioChunk, type ImageChunk } from '../content/content.js';\n\n/** Well defined GenerateContent Action */\nexport abstract class GenerateContent extends Action {\n    abstract override run(session: Session, inputs: { prompt: Input }, outputs: { response?: Output }): Promise<void>;\n}\n\n/** Well defined Live Action */\nexport abstract class Live extends Action {\n    abstract override run(session: Session, \n        inputs: { \n            audio?: Input<AudioChunk>, \n            video?: Input<ImageChunk>, \n            screen?: Input<ImageChunk>, \n            context?: Input, \n            system?: Input,\n        }, \n        outputs: { \n            audio?: Output<AudioChunk>, \n            context?: Output,\n        }): Promise<void>;\n}\n", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Input, Output, Action, Session } from '../interfaces.js';\nimport { chunkText, textChunk, ROLE} from '../content/content.js';\n\n/** Reverse some content. */\nexport class ReverseContent extends Action {\n    async run(session: Session, inputs: { prompt: Input }, outputs: { response: Output }) {\n        for await (const chunk of inputs.prompt) {\n            const text = chunkText(chunk);\n            const reverse = text.split(\"\").reverse().join(\"\");\n            await outputs.response.write(textChunk(reverse, { role: ROLE.ASSISTANT }));\n        }\n        await outputs.response.close();\n    }\n}", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * as genai from './genai.js';", "\n/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Input, Output, Session, Chunk } from '../../interfaces.js';\nimport { GoogleGenAI, Modality, LiveConnectConfig, LiveServerMessage } from \"@google/genai\";\nimport { GenerateContent as AbstractGenerateContent, Live as AbstractLive } from '../common.js';\nimport { chunkText, textChunk, AudioChunk, ImageChunk } from '../../content/content.js';\nimport { parseMimetype, stringifyMimetype } from '../../content/mime.js';\nimport { encode as b64encode, decode as b64decode } from '../../base64/index.js';\nimport { merge } from '../../async/index.js';\n\n\nconst clients = new Map<string, GoogleGenAI>();\nfunction genAI(apiKey: string) {\n    let client = clients.get(apiKey);\n    if (!client) {\n        client = new GoogleGenAI({ apiKey, apiVersion: 'v1alpha' });\n        clients.set(apiKey, client);\n    }\n    return client;\n}\n\nexport class Live extends AbstractLive {\n\n    constructor(private readonly apiKey: string, private readonly model = 'gemini-2.0-flash-exp') {\n        super();\n    }\n\n    override async run(session: Session,\n        inputs: {\n            audio?: Input<AudioChunk>,\n            video?: Input<ImageChunk>,\n            screen?: Input<ImageChunk>,\n            context?: Input,\n            system?: Input,\n        },\n        outputs: {\n            audio?: Output<AudioChunk>,\n            context?: Output,\n        }): Promise<void> {\n\n        const client = genAI(this.apiKey);\n        const config: LiveConnectConfig = {\n            responseModalities: [Modality.AUDIO]\n        };\n\n        if (inputs.system) {\n            const system = await inputs.system;\n            const systemString = system.map((c) => chunkText(c)).join(\"\");\n            config.systemInstruction = {\n                parts: [{ text: systemString }],\n            }\n        }\n\n        const live = await client.live.connect({\n            model: this.model, config, callbacks: {\n                onmessage: (e) => {\n                    void onmessage(e);\n                },\n                onerror: (e) => {\n                    console.log('error', e);\n                },\n                onclose: (e) => {\n                    console.log('close', e);\n                },\n                onopen: () => {\n                    console.log('open');\n                },\n            }\n        });\n\n        async function readInputs() {\n            const arr = [inputs.audio, inputs.video, inputs.screen].filter((x) => !!x);\n            if (arr.length === 0) return;\n            for await (const chunk of merge(...arr)) {\n                if (chunk.data) {\n                    live.sendRealtimeInput({\n                        media: {\n                            mimeType: stringifyMimetype(chunk.metadata.mimetype),\n                            data: b64encode(chunk.data),\n                        }\n                    });\n                }\n            }\n        }\n\n        async function readContext() {\n            if (!inputs.context) {\n                return;\n            }\n            for await (const chunk of inputs.context) {\n                if (chunk.data) {\n                    live.sendClientContent({\n                        turns: [{\n                            parts: [{\n                                text: chunkText(chunk),\n                            }],\n                        }],\n                        turnComplete: false,\n                    });\n                }\n            }\n        }\n\n        async function onmessage(resp: LiveServerMessage) {\n            if (resp.serverContent?.modelTurn) {\n                const turn = resp.serverContent.modelTurn;\n                if (turn.parts) {\n                    for (const part of turn.parts) {\n                        if (part.text) {\n                            const chunk = textChunk(part.text);\n                            await outputs.context?.write(chunk);\n                        } else if (part.inlineData) {\n                            const chunk: Chunk = {\n                                data: b64decode(part.inlineData.data ?? ''),\n                                metadata: {\n                                    mimetype: parseMimetype(part.inlineData.mimeType),\n                                }\n                            };\n                            if (chunk.metadata?.mimetype?.type === 'audio') {\n                                await outputs.audio?.write(chunk as AudioChunk);\n                            } else {\n                                await outputs.context?.write(chunk);\n                            }\n                        }\n                    }\n                }\n            }\n            if (resp.serverContent?.turnComplete) {\n                console.log('complete turn');\n                return;\n            }\n            if (resp.serverContent?.interrupted) {\n                console.log('interupted turn');\n                return;\n            }\n            if (resp.toolCall) {\n                console.log('toolCall');\n                return;\n            }\n            if (resp.toolCallCancellation) {\n                console.log('toolCancellation');\n                return;\n            }\n        }\n\n        async function writeOutputs() {\n            await new Promise(() => {\n                // TODO(doug): When should this actually finish and close.\n                // await outputs.context?.close();\n                // await outputs.audio?.close();\n            });\n        }\n\n        void readInputs();\n        void readContext();\n        await writeOutputs();\n    }\n}\n\n\n/** Well defined GenerateContent Action */\nexport class GenerateContent extends AbstractGenerateContent {\n\n    constructor(private readonly apiKey: string, private readonly model: string) {\n        super();\n    }\n\n    override async run(session: Session, inputs: { prompt: Input }, outputs: { response?: Output }): Promise<void> {\n        if (!outputs.response) {\n            return;\n        }\n        const prompt = await inputs.prompt;\n        const promptString = prompt.map((c) => chunkText(c)).join(\"\");\n        const response = await genAI(this.apiKey).models.generateContentStream({\n            model: this.model,\n            contents: promptString,\n        });\n        for await (const chunk of response) {\n            const text = chunk.text;\n            if (text) {\n                await outputs.response.write(textChunk(text));\n            }\n        }\n    }\n}\n", "/** \n * @fileoverview base64 helper utilities.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** Encodes Uint8Array to base64 string. */\nexport function encode(bytes: Uint8Array): string {\n  let binary = '';\n  const len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n\n/** Decodes base64 string to Uint8Array. */\nexport function decode(base64: string): Uint8Array {\n  const binaryString = atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}\n", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from './drive.js';", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\n// Create an OAuth client ID at https://console.cloud.google.com/apis/credentials.\nlet OAUTH_CLIENT_ID = '';\nconst OAUTH_SCOPES = ['https://www.googleapis.com/auth/documents.readonly'];\n\nfunction oauthSignIn() {\n  const oauth2Endpoint = 'https://accounts.google.com/o/oauth2/v2/auth';\n  const form = document.createElement('form');\n  form.setAttribute('method', 'GET');\n  form.setAttribute('action', oauth2Endpoint);\n  if (!OAUTH_CLIENT_ID) {\n\tOAUTH_CLIENT_ID = prompt(\"Google OAuth client\") ?? '';\n  } \n  const params: Record<string, string> = {\n\t\t'client_id': OAUTH_CLIENT_ID,\n\t\t// TODO: update with the URL if this is hosted persistently.\n\t\t// Register the domain under \"Authorized JavaScript origins\" and\n\t\t// \"Authorized redirect URIs\" in the Google Cloud console.\n\t\t'redirect_uri': 'http://localhost:5432/examples/drive',\n\t\t'response_type': 'token',\n\t\t'scope': OAUTH_SCOPES.join(' '),\n\t\t'include_granted_scopes': 'true',\n\t\t'state': 'pass-through value'\n\t};\n  for (const [k,v] of Object.entries(params)) {\n    const input = document.createElement('input');\n    input.setAttribute('type', 'hidden');\n    input.setAttribute('name', k);\n    input.setAttribute('value', v);\n    form.appendChild(input);\n  }\n  document.body.appendChild(form);\n  form.submit();\n\n}\n\nlet authTried = false;\n\nexport function maybeAuthenticate() {\n\tif (authTried) {\n\t\treturn;\n\t}\n\tauthTried = true;\n\tconst fragmentString = location.hash.substring(1);\n\tconst params: Record<string, string> = {};\n\tconst regex = /([^&=]+)=([^&]*)/g;\n\tlet m: RegExpExecArray | null = null;\n\twhile ((m = regex.exec(fragmentString)) !== null) {\n\t\tparams[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);\n\t}\n\tif (Object.keys(params).length > 0 && params['state']) {\n\t\tconst paramsJson = JSON.stringify(params);\n\t\tlocalStorage.setItem('oauth2-test-params', paramsJson);\n\t} else {\n\t\toauthSignIn();\n\t}\n}\n", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Processor} from '../../interfaces.js';\nimport {textChunk, chunkText} from '../../content/content.js';\nimport { maybeAuthenticate } from './auth.js';\n\nconst DOCS_API = 'https://docs.googleapis.com/v1/documents/';\n\ninterface TextRun {\n  content?: string;\n}\n\ninterface Element {\n  textRun: TextRun;\n}\n\ninterface Paragraph {\n  elements: Element[];\n}\n\ninterface Content {\n  paragraph?: Paragraph;\n}\n\ninterface Body {\n  content: Content[];\n}\n\ninterface Document {\n  title: string;\n  body: Body;\n}\n\nfunction documentToText(document: Document) {\n  let documentText = '';\n  documentText += document.title + '<br><br>';\n  for (const content of document.body.content) {\n    if (content.paragraph) {\n      for (const element of content.paragraph.elements) {\n        if (element.textRun.content) {\n          documentText += element.textRun.content;\n        }\n      }\n    }\n  }\n  return documentText;\n}\n\ndeclare interface DocParams {\n  access_token?: string;\n}\n\nasync function fetchDocument(url: string) {\n  const match = /\\/d\\/([a-zA-Z0-9-_]+)/.exec(url);\n  if (!match) {\n    throw new Error(`Bad url ${url}`)\n  }\n  const docsId = match[1];\n  const docsApi = `${DOCS_API}${docsId}`;\n  const params = JSON.parse(localStorage.getItem('oauth2-test-params') ?? '{}') as DocParams;\n  const response = await fetch(\n    `${docsApi}?access_token=${params.access_token}`);\n  const documentData = await response.json() as Document;\n  return documentData;\n}\n\n/** Converts a docUrl imput to docText. */\nexport const docToText: Processor<'docUrl', 'docText'> =\n    async function*(chunks) {\n\n  maybeAuthenticate();\n\n  for await (const [k, c] of chunks) {\n    if (k === 'docUrl') {\n      const document = await fetchDocument(chunkText(c));\n      const documentText = documentToText(document);\n      yield ['docText', textChunk(documentText)];\n    } else {\n      yield [k, c];\n    }\n  }\n}\n", "/**\n * @fileoverview Evergreen.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from './actions.js';\nexport * from './evergreen_spec.js';\nexport * from './interfaces.js';\nexport {\n  AbstractBaseConnectionManager,\n  CachingConnectionManagerFactory,\n} from './net.js';\nexport type {ConnectionManager, SessionMessageCallbackFn} from './net.js';\nexport * from './run.js';\n", "/**\n * @fileoverview Evergreen actions.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ActionSchema} from './interfaces.js';\n\n/** Generate action */\nexport const GENERATE = {\n  name: 'GENERATE',\n  inputs: [\n    {\n      name: 'prompt',\n      description: 'The prompt to generate from',\n      type: [\n        {type: 'text', subtype: 'plain'},\n        {type: 'image', subtype: 'png'},\n      ],\n    },\n  ],\n  outputs: [\n    {\n      name: 'response',\n      description: 'The response from the model',\n      type: [\n        {type: 'text', subtype: 'plain'},\n        {type: 'image', subtype: 'png'},\n      ],\n    },\n  ],\n} as const satisfies ActionSchema;\n\n/** Generate action type */\nexport type GENERATE = typeof GENERATE;", "/**\n * @fileoverview Abstractions for the network layer required to execute\n * Evergreen actions on remote servers from a web browser client. As well as\n * a default implementation that uses WebSockets for network transport.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Session } from '../../interfaces.js';\n\nimport * as eg from './evergreen_spec.js';\n\n/**\n * Interface for callback functions that are invoked by the\n * `ConnectionManager` when a `SessionMessage` is received from the remote\n * server.\n */\nexport type SessionMessageCallbackFn = (message: eg.SessionMessage) => void;\n\n/**\n * `ConnectionManager` is the interface between Evergreen action execution\n * methods defined in `run.ts` and the network transport used to communicate\n * with the remote server. `T` is the type of response message expected from\n * the remote server.\n */\nexport declare interface ConnectionManager<T> {\n  /**\n   * Registers a `SesionMessageCallbackFn` to be invoked when a `SessionMessage`\n   * is received from the remote server. If multiple callbacks are registered\n   * then they will each be invoked for each `SessionMessage` received.\n   */\n  registerSessionMessageCallback(callback: SessionMessageCallbackFn): void;\n\n  /**\n   * Establish a connection to the remote server. This is a no-op if the\n   * connection is already established.\n   */\n  connect(): Promise<void>;\n\n  /**\n   * End the connection to the remote server. This is a no-op if the connection\n   * is already closed or was never established.\n   */\n  disconnect(): void;\n\n  /**\n   * Send a message to the remote server.\n   */\n  send(message: eg.SessionMessage): void;\n\n  /**\n   * Callback that is invoked when a response is received from the\n   * remote server. Note that implementers of this interface must ensure\n   * that this callback is invoked e.g. by registering an event listener\n   * on the underlying network connection.\n   */\n  onServerResponse(message: T): Promise<void>;\n\n  /**\n   * Callback that is invoked when an error is received from the remote server.\n   * Note that implementers of this interface must ensure that this callback is\n   * invoked e.g. by registering an event listener on the underlying network\n   * connection.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onError(event: any): void;\n\n  /**\n   * Callback that is invoked when the connection is closed. Note that\n   * implementers of this interface must ensure that this callback is invoked\n   * e.g. by registering an event listener on the underlying network connection.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onClose(event: any): void;\n\n  /**\n   * Returns `true` if the connection is considered \"valid\" and `false`\n   * otherwise. The exact semantics of valid and invalid are up to the\n   * interface implementer. A connection which is invalid will be disposed\n   * of and a new connection will be created to replace it.\n   */\n  isValidConnection(): boolean;\n}\n\n/**\n * Abstract base implementation of the `ConnectionManager` interface. This\n * base class provides a default implementation of the `onServerResponse`\n * method. The default implementation converts the raw server response into\n * a `SessionMessage` object and notifies any registered callbacks of the newly\n * available `SessionMessage`. Implementers must provide their own concrete\n * implementation of the `convertServerResponseToSessionMessage` method which\n * performs the conversion from the raw server response to a `SessionMessage`\n * object.\n */\nexport abstract class AbstractBaseConnectionManager<T>\n  implements ConnectionManager<T> {\n  private callbacks: SessionMessageCallbackFn[] = [];\n\n  /**\n   * Method defined in interface. Registers the provided `callback` in an\n   * internal array of callbacks. Each callback will be invoked when a new\n   * `SessionMessage` is received from the remote server.\n   */\n  registerSessionMessageCallback(callback: SessionMessageCallbackFn): void {\n    this.callbacks.push(callback);\n  }\n\n  /**\n   * Method defined in interface. Implementers must override this method with\n   * a concrete implementation. Refer to interface documentation for more\n   * details.\n   */\n  abstract connect(): Promise<void>;\n\n  /**\n   * Method defined in interface. Implementers must override this method with\n   * a concrete implementation. Refer to interface documentation for more\n   * details.\n   */\n  abstract disconnect(): void;\n\n  /**\n   * Method defined in interface. Implementers must override this method with\n   * a concrete implementation. Refer to interface documentation for more\n   * details.\n   */\n  abstract send(message: eg.SessionMessage): void;\n\n  /**\n   * Method defined in interface. Implementers must override this method with\n   * a concrete implementation. Refer to interface documentation for more\n   * details.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  abstract onError(event: any): void;\n\n  /**\n   * Method defined in interface. Implementers must override this method with\n   * a concrete implementation. Refer to interface documentation for more\n   * details.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  abstract onClose(event: any): void;\n\n  /**\n   * Method defined in interface. Implementers must override this method with\n   * a concrete implementation. Refer to interface documentation for more\n   * details.\n   */\n  abstract isValidConnection(): boolean;\n\n  /**\n   * Default implementation of the `onServerResponse` method. This method\n   * converts the raw server response into a `SessionMessage` object and emits\n   * it via the registered callbacks. Implementers must provide their\n   * own concrete implementation of the `convertServerResponseToSessionMessage`\n   * method below.\n   */\n  async onServerResponse(event: T): Promise<void> {\n    const message: eg.SessionMessage | undefined =\n      await this.convertServerResponseToSessionMessage(event);\n    if (message) {\n      for (const callback of this.callbacks) {\n        callback(message);\n      }\n    }\n  }\n\n  /**\n   * Converts the raw server response into a `SessionMessage` object. If the\n   * response does not represent a valid `SessionMessage` then either an\n   * error should be raised or `undefined` should be returned. If the response\n   * is expected but simply doesn't represent a `SessionMessage`, e.g. the\n   * response represents some network control metadata, then the appropriate\n   * behavior is to return `undefined`. However, if the response is not\n   * expected and represents an error, then an error should be raised.\n   */\n  protected abstract convertServerResponseToSessionMessage(\n    event: T,\n  ): Promise<eg.SessionMessage | undefined>;\n}\n\n/**\n * Function that instantiates new `WebSocketConnectionManager`s. This is\n * intended to be used as the `createManagerFn` argument to the\n * `CachingConnectionManagerFactory` constructor.\n */\nexport function WebSocketConnectionManagerFactoryFn(\n  backendUrl: string,\n): WebSocketConnectionManager {\n  return WebSocketConnectionManager.createWithUrl(backendUrl);\n}\n\n/**\n * Implementation of the `ConnectionManager` interface that uses WebSockets\n * for network transport.\n */\nexport class WebSocketConnectionManager extends AbstractBaseConnectionManager<MessageEvent> {\n  private readonly socket: WebSocket;\n\n  private constructor(backendUrl?: string, socket?: WebSocket) {\n    super();\n    if (backendUrl) {\n      this.socket = new WebSocket(backendUrl);\n    } else if (socket) {\n      this.socket = socket;\n    } else {\n      throw new Error('Either backendUrl or socket must be provided.');\n    }\n    this.socket.binaryType = 'blob';\n  }\n\n  static createWithUrl(backendUrl: string): WebSocketConnectionManager {\n    return new WebSocketConnectionManager(backendUrl);\n  }\n\n  static createWithSocket(socket: WebSocket): WebSocketConnectionManager {\n    return new WebSocketConnectionManager(undefined, socket);\n  }\n\n  override isValidConnection(): boolean {\n    return this.socket.readyState === WebSocket.OPEN;\n  }\n\n  override async connect(): Promise<void> {\n    if (this.isValidConnection()) {\n      console.info('WebSocket already connected');\n      return;\n    }\n    await new Promise<void>((resolve, reject) => {\n      this.socket.addEventListener('open', () => {\n        this.socket.removeEventListener('error', reject);\n        this.socket.removeEventListener('close', reject);\n        resolve();\n      });\n      this.socket.addEventListener('error', reject);\n      this.socket.addEventListener('close', reject);\n    });\n    this.socket.onmessage = async (event: MessageEvent) => {\n      await this.onServerResponse(event);\n    };\n    this.socket.onerror = (event: Event) => {\n      this.onError(event);\n    };\n    this.socket.onclose = (event: CloseEvent) => {\n      this.onClose(event);\n    };\n  }\n\n  override disconnect(): void {\n    // TODO(geoffdowns): not in original implementation. Remove? Retain?\n    this.socket.close();\n  }\n\n  override send(message: eg.SessionMessage): void {\n    this.socket.send(JSON.stringify(message));\n  }\n\n  override async convertServerResponseToSessionMessage(\n    event: MessageEvent,\n  ): Promise<eg.SessionMessage | undefined> {\n    let message: eg.SessionMessage;\n    switch (event.type) {\n      case 'text':\n      case 'message':\n      case 'binary':\n        const data = event.data as unknown;\n        if (data instanceof Blob) {\n          const buf = await data.arrayBuffer();\n          message = JSON.parse(\n            new TextDecoder().decode(new Uint8Array(buf)),\n          ) as eg.SessionMessage;\n        } else if (data instanceof ArrayBuffer) {\n          message = JSON.parse(\n            new TextDecoder().decode(new Uint8Array(data)),\n          ) as eg.SessionMessage;\n        } else if (typeof data === 'string') {\n          message = JSON.parse(data) as eg.SessionMessage;\n        } else {\n          throw new Error(\n            `Unsupported type ${this.socket.binaryType} ${typeof data}`,\n          );\n        }\n        break;\n      default:\n        throw new Error(`Unknown message type ${event.type}`);\n    }\n    return message;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  override onError(event: any) {\n    console.info('Websocket error', event, this.socket);\n  }\n\n  override onClose(event: CloseEvent) {\n    // See\n    // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code#value\n    // for mapping from code to explanation.\n    console.info(\n      `Websocket closed: ${event.reason} ${event.code}`,\n      event,\n      this.socket,\n    );\n  }\n}\n\n/**\n * Factory for creating `ConnectionManager`s. This factory caches\n * `ConnectionManager`s for a given `Session`. Previously cached\n * `ConnectionManager`s are only returned if they are considered \"valid\".\n * Implementers of the `ConnectionManager` interface must define what it means\n * for a connection to be valid or invalid. Typically this will be based on\n * the state of the underlying network connection, e.g. a `WebSocket` in the\n * `WebSocket.OPEN` state would be considered valid and all other states would\n * be considered invalid.\n */\nexport class CachingConnectionManagerFactory<T> {\n  private readonly connectionMap = new Map<Session, ConnectionManager<T>>();\n  private readonly createManagerFn: (\n    backendUrl: string,\n  ) => ConnectionManager<T>;\n\n  constructor(createManagerFn: (backendUrl: string) => ConnectionManager<T>) {\n    this.createManagerFn = createManagerFn;\n  }\n\n  getConnection(session: Session, backendUrl: string): ConnectionManager<T> {\n    let manager = this.connectionMap.get(session);\n    if (manager) {\n      if (manager.isValidConnection()) {\n        return manager;\n      } else {\n        manager = undefined;\n        this.connectionMap.delete(session);\n      }\n    }\n\n    manager = this.createManagerFn(backendUrl);\n    this.connectionMap.set(session, manager);\n    return manager;\n  }\n}\n", "/**\n * @fileoverview Evergreen actions.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { decode as b64decode, encode as b64encode } from '../../base64/index.js';\nimport { parseMimetype, stringifyMimetype } from '../../content/mime.js';\nimport {\n  Action,\n  Chunk,\n  ChunkMetadata,\n  Input,\n  Session,\n} from '../../interfaces.js';\n\nimport * as eg from './evergreen_spec.js';\nimport {\n  ActionFromSchema,\n  ActionInputs,\n  ActionOutputs,\n  ActionSchema,\n} from './interfaces.js';\nimport {\n  CachingConnectionManagerFactory,\n  ConnectionManager,\n  WebSocketConnectionManagerFactoryFn,\n} from './net.js';\n\nexport interface StreamIdGenerator {\n  generateStreamId(streamName: string): string;\n}\n\nclass UuidStreamIdGenerator implements StreamIdGenerator {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  generateStreamId(streamName: string): string {\n    return crypto.randomUUID();\n  }\n}\n\nexport class Options {\n  constructor(\n    readonly backend: string,\n    readonly idGenerator: StreamIdGenerator,\n    readonly connectionFactory: CachingConnectionManagerFactory<unknown>,\n  ) { }\n}\n\nfunction getUuids<T extends ActionSchema>(\n  inputs: ActionInputs<T>,\n  outputs: ActionOutputs<T>,\n  idGenerator: StreamIdGenerator,\n): [Record<string, string>, Record<string, string>] {\n  const outputIds: Record<string, string> = {};\n  for (const outputKey of Object.keys(outputs)) {\n    outputIds[outputKey] = idGenerator.generateStreamId(outputKey);\n  }\n  const inputIds: Record<string, string> = {};\n  for (const inputKey of Object.keys(inputs)) {\n    inputIds[inputKey] = idGenerator.generateStreamId(inputKey);\n  }\n  return [inputIds, outputIds];\n}\n\nasync function writeToOutputs<T extends ActionSchema>(\n  msg: eg.SessionMessage,\n  outputIds: Record<string, string>,\n  outputs: ActionOutputs<T>,\n  childIdMapping: Record<string, string>,\n  pending: Record<string, eg.NodeFragment[]>,\n) {\n  for (const nodeFragment of msg.nodeFragments ?? []) {\n    const key = nodeFragment.id;\n    if (!key) {\n      console.warn('nodeFragment missing id');\n      continue;\n    }\n    if (nodeFragment.childIds) {\n      for (const childId of nodeFragment.childIds) {\n        childIdMapping[childId] = childIdMapping[key];\n        const existing = pending[childId];\n        if (existing) {\n          const copy = [...existing];\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete pending[childId];\n          for (const existingNodeFragment of copy) {\n            await writeToOutputs(\n              { nodeFragments: [existingNodeFragment] },\n              outputIds,\n              outputs,\n              childIdMapping,\n              pending,\n            );\n          }\n        }\n      }\n      const streamKey = childIdMapping[key];\n      const stream = outputs[streamKey as keyof ActionOutputs<T>];\n      if (stream && !nodeFragment.continued && outputIds[key]) {\n        await stream.close();\n      }\n      continue;\n    }\n    const streamKey = childIdMapping[key];\n    if (!streamKey) {\n      const existing = pending[key] ?? [];\n      existing.push(nodeFragment);\n      pending[key] = existing;\n      continue;\n    }\n    const stream = outputs[streamKey as keyof ActionOutputs<T>];\n    const metadata: ChunkMetadata = {\n      mimetype: parseMimetype(nodeFragment.chunkFragment?.metadata?.mimetype),\n      role: nodeFragment.chunkFragment?.metadata?.role,\n    };\n    const data = nodeFragment.chunkFragment?.data\n      ? b64decode(nodeFragment.chunkFragment.data)\n      : undefined;\n    const ref = nodeFragment.chunkFragment?.ref;\n    const chunk = data ? { metadata, data } : ref ? { metadata, ref } : { metadata };\n    await stream.write(chunk as Chunk);\n    if (!nodeFragment.continued && outputIds[key]) {\n      await stream.close();\n    }\n  }\n}\n\nfunction sendAction(\n  connectionManager: ConnectionManager<unknown>,\n  uri: string,\n  action: ActionSchema,\n  inputIds: Record<string, string>,\n  outputIds: Record<string, string>,\n) {\n  const actionMessage: eg.SessionMessage = {\n    actions: [\n      {\n        targetSpec: {\n          id: uri,\n        },\n        name: action.name,\n        inputs: Object.keys(inputIds).map((input) => {\n          return {\n            name: input,\n            id: inputIds[input],\n          };\n        }),\n        outputs: Object.keys(outputIds).map((output) => {\n          return {\n            name: output,\n            id: outputIds[output],\n          };\n        }),\n      },\n    ],\n  };\n  connectionManager.send(actionMessage);\n}\n\n// Read the response.\nfunction sendInput<T extends ActionSchema>(\n  connectionManager: ConnectionManager<unknown>,\n  inputs: ActionInputs<T>,\n  inputIds: Record<string, string>,\n) {\n  for (const [k, v] of Object.entries(inputs)) {\n    void (async (key: string, stream: Input) => {\n      let seq = 0;\n      for await (const chunk of stream) {\n        const chunkFragment: eg.Chunk = {};\n        chunkFragment.metadata = {\n          mimetype: stringifyMimetype(chunk.metadata?.mimetype),\n          role: chunk.metadata?.role,\n        };\n        if (chunk.data) {\n          chunkFragment.data = b64encode(chunk.data);\n        }\n        const dataMsg: eg.SessionMessage = {\n          nodeFragments: [\n            {\n              id: inputIds[key],\n              chunkFragment,\n              seq: seq++,\n              continued: true,\n            },\n          ],\n        };\n        connectionManager.send(dataMsg);\n      }\n      // close\n      const closeMsg: eg.SessionMessage = {\n        nodeFragments: [\n          {\n            id: inputIds[key],\n            seq: seq++,\n            continued: false,\n          },\n        ],\n      };\n      connectionManager.send(closeMsg);\n    })(k, v as Input);\n  }\n}\n\nasync function runEvergreenAction<T extends ActionSchema>(\n  session: Session,\n  uri: string,\n  action: T,\n  inputs: ActionInputs<T>,\n  outputs: ActionOutputs<T>,\n  options: Options,\n) {\n  const connectionManager = options.connectionFactory.getConnection(\n    session,\n    options.backend,\n  );\n  await connectionManager.connect();\n\n  // Create uuids for the input and output streams.\n  const [inputIds, outputIds] = getUuids(inputs, outputs, options.idGenerator);\n  const childIdMapping: Record<string, string> = {};\n  for (const output of Object.keys(outputIds)) {\n    childIdMapping[outputIds[output]] = output;\n  }\n  const pending: Record<string, eg.NodeFragment[]> = {};\n\n  connectionManager.registerSessionMessageCallback((msg: eg.SessionMessage) => {\n    void writeToOutputs(msg, outputIds, outputs, childIdMapping, pending);\n  });\n\n  sendAction(connectionManager, uri, action, inputIds, outputIds);\n  sendInput(connectionManager, inputs, inputIds);\n\n  // TODO(doug): await all the writes to finish.\n}\nclass EvergreenAction<T extends ActionSchema> extends Action {\n  constructor(\n    private readonly uri: string,\n    private readonly action: T,\n    private readonly options: Options,\n  ) {\n    super();\n  }\n  async run(\n    session: Session,\n    inputs: ActionInputs<T>,\n    outputs: ActionOutputs<T>,\n  ) {\n    await runEvergreenAction(\n      session,\n      this.uri,\n      this.action,\n      inputs,\n      outputs,\n      this.options,\n    );\n  }\n}\n\nconst defaultConnectionFactory =\n  new CachingConnectionManagerFactory<unknown>(WebSocketConnectionManagerFactoryFn);\n\nlet lazyBackend: string | undefined = undefined;\n\n/** Sets the backend address wss://myapi/address?key=mykey. */\nexport function setBackend(address: string) {\n  lazyBackend = address;\n}\n\nfunction getBackend(): string {\n  if (lazyBackend === undefined) {\n    throw new Error('No backend address set, call setBackend().');\n  }\n  return lazyBackend;\n}\n\nexport function action<T extends ActionSchema>(\n  uri: string,\n  action: T,\n  options?: Options,\n): ActionFromSchema<T> {\n  options ??= new Options(\n    getBackend(),\n    new UuidStreamIdGenerator(),\n    defaultConnectionFactory,\n  );\n  return new EvergreenAction<T>(uri, action, options);\n}\n"],
  "mappings": "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",
  "names": ["prompt", "ROLE", "prompt", "GenerateContent", "Live", "Live", "writeOutputs", "GenerateContent", "prompt", "document", "streamKey", "stream", "action"]
}
