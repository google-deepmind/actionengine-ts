{
  "version": 3,
  "sources": ["../interfaces.js", "../content/index.js", "../content/mime.js", "../content/content.js", "../stream/stream.js", "../content/prompt.js", "../content/audio.js", "../content/video.js", "../sessions/index.js", "../async/index.js", "../sessions/utils.js", "../sessions/session.js", "../sessions/local.js", "../sessions/middleware/index.js", "../sessions/middleware/debug.js", "../actions/index.js", "../actions/common.js", "../actions/toy.js", "../actions/google/index.js", "../actions/google/genai.js", "../base64/index.js", "../actions/drive/index.js", "../actions/drive/auth.js", "../actions/drive/drive.js", "../actions/evergreen/index.js", "../actions/evergreen/run.js", "../actions/evergreen/actions.js"],
  "sourcesContent": ["/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport class Action {\n}\n// Session Interfaces End\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nexport * from './content.js';\nexport * from './prompt.js';\nexport * from './audio.js';\nexport * from './video.js';\nexport * from './mime.js';\n", "/**\n * @fileoverview Utilities for processing content chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Converts a mimetype to a string.\n */\nexport function stringifyMimetype(mimetype) {\n    if (!mimetype) {\n        return 'application/octet-stream';\n    }\n    let result = '';\n    if (!mimetype.type) {\n        return result;\n    }\n    result += mimetype.type;\n    if (!mimetype.subtype) {\n        return result;\n    }\n    result += '/';\n    if (mimetype.prefix) {\n        result += `${mimetype.prefix}.`;\n    }\n    result += mimetype.subtype;\n    if (mimetype.suffix) {\n        result += `+${mimetype.suffix}`;\n    }\n    if (mimetype.parameters) {\n        for (const [key, value] of Object.entries(mimetype.parameters)) {\n            result += `;${key}=${value}`;\n        }\n    }\n    return result;\n}\n/**\n * Parses a mimetype from a string.\n */\nexport function parseMimetype(mimetype) {\n    if (!mimetype) {\n        return { type: 'application', subtype: 'octet-stream' };\n    }\n    let parameters = undefined;\n    const paramParts = mimetype.split(';');\n    if (paramParts.length > 1) {\n        mimetype = mimetype.substring(0, paramParts[0].length);\n        parameters = {};\n        for (let i = 1; i < paramParts.length; i++) {\n            const [key, value] = paramParts[i].trim().split('=');\n            parameters[key] = value;\n        }\n    }\n    const parts = mimetype.split('/');\n    if (parts.length !== 2) {\n        throw new Error(`Invalid mimetype: ${mimetype}`);\n    }\n    const [type, rest] = parts;\n    let subtype = undefined;\n    let prefix = undefined;\n    let suffix = undefined;\n    const vndSplit = rest.lastIndexOf('.');\n    if (vndSplit >= 0) {\n        prefix = rest.slice(0, vndSplit);\n        subtype = rest.slice(vndSplit + 1);\n    }\n    else {\n        subtype = rest;\n    }\n    const suffixSplit = subtype.indexOf('+');\n    if (suffixSplit >= 0) {\n        suffix = subtype.slice(suffixSplit + 1);\n        subtype = subtype.slice(0, suffixSplit);\n    }\n    return {\n        type,\n        subtype,\n        prefix,\n        suffix,\n        parameters,\n    };\n}\n", "/**\n * @fileoverview Utilities for processing content chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { stringifyMimetype, parseMimetype } from './mime.js';\n/** Role enum definition. */\nexport var ROLE;\n(function (ROLE) {\n    ROLE[\"USER\"] = \"USER\";\n    ROLE[\"ASSISTANT\"] = \"ASSISTANT\";\n    ROLE[\"SYSTEM\"] = \"SYSTEM\";\n    ROLE[\"CONTEXT\"] = \"CONTEXT\";\n})(ROLE || (ROLE = {}));\n/**\n * Type assertion the chunk is a text.\n */\nexport function isTextChunk(maybeChunk) {\n    return maybeChunk.metadata?.mimetype?.type === 'text';\n}\n/**\n * Type assertion the chunk is a json.\n */\nexport function isJsonChunk(maybeChunk) {\n    const chunk = maybeChunk;\n    const mimetype = chunk.metadata?.mimetype;\n    return mimetype?.type === 'application' && mimetype.subtype === 'json';\n}\n/**\n * Type assertion the chunk is a blob.\n */\nexport function isRefChunk(maybeChunk) {\n    return maybeChunk.ref !== undefined;\n}\n/**\n * Type assertion the chunk is data.\n */\nexport function isDataChunk(maybeChunk) {\n    return maybeChunk.data !== undefined;\n}\n/**\n * Type assertion the chunk is a chunk.\n */\nexport function isChunk(maybeChunk) {\n    const c = maybeChunk;\n    return !!(c.metadata ?? c.data ?? c.ref);\n}\n/**\n * Creates a json chunk.\n */\nexport function jsonChunk(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\njson, metadata = {}, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nreplacer) {\n    const defaultMetadata = {\n        captureTime: new Date(),\n    };\n    return {\n        metadata: {\n            ...defaultMetadata,\n            ...metadata,\n            mimetype: {\n                ...metadata.mimetype,\n                type: 'application',\n                subtype: 'json',\n            },\n        },\n        data: new TextEncoder().encode(JSON.stringify(json, replacer)),\n    };\n}\n/**\n * Converts a chunk to json.\n */\nexport function chunkJson(chunk, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nreviver) {\n    if (isJsonChunk(chunk)) {\n        if (isDataChunk(chunk)) {\n            const text = new TextDecoder().decode(chunk.data);\n            return JSON.parse(text, reviver);\n        }\n        if (chunk.ref) {\n            // TODO(doug): Implement ref chunk.\n            throw new Error('Ref chunk not yet implemented');\n        }\n        return null;\n    }\n    throw new Error('Not a json mimetype for the chunk.');\n}\n/**\n * Creates a plain text chunk.\n */\nexport function textChunk(text, metadata = {}) {\n    const defaultMetadata = {\n        captureTime: new Date(),\n    };\n    return {\n        metadata: {\n            ...defaultMetadata,\n            ...metadata,\n            mimetype: {\n                ...metadata.mimetype,\n                type: 'text',\n                subtype: 'plain',\n            },\n        },\n        data: new TextEncoder().encode(text),\n    };\n}\n/**\n * Converts a chunk to text.\n */\nexport function chunkText(chunk, throwOnError = false) {\n    if (isTextChunk(chunk)) {\n        if (isDataChunk(chunk)) {\n            const text = new TextDecoder().decode(chunk.data);\n            return text;\n        }\n        if (chunk.ref) {\n            // TODO(doug): Implement ref chunk.\n            throw new Error('Ref chunk not yet implemented');\n        }\n        return '';\n    }\n    if (throwOnError) {\n        throw new Error(`Unsupported chunk type: ${JSON.stringify(chunk)}`);\n    }\n    // Unknown chunk type stringify as best as possible.\n    return JSON.stringify(chunk);\n}\n/**\n * Converts a chunk to a blob.\n */\nexport function chunkBlob(chunk) {\n    let parts;\n    if (isDataChunk(chunk)) {\n        parts = [chunk.data];\n    }\n    else {\n        // TODO(doug): Implement ref chunk.\n        throw new Error('Ref chunk not yet implemented');\n    }\n    const blob = new Blob(parts, {\n        type: stringifyMimetype(chunk.metadata?.mimetype),\n    });\n    return blob;\n}\n/**\n * Converts a image to a chunk.\n */\nexport async function imageChunk(image, metadata = {}) {\n    // Wait for image to load if not already loaded.\n    if (!image.complete) {\n        await new Promise((resolve) => {\n            image.addEventListener('load', () => {\n                resolve();\n            }, { once: true });\n        });\n    }\n    const canvas = new OffscreenCanvas(image.width, image.height);\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        throw new Error('Failed to get 2d context');\n    }\n    ctx.drawImage(image, 0, 0, image.width, image.height);\n    const blob = await canvas.convertToBlob();\n    return await blobChunk(blob, metadata);\n}\n/**\n * Returns a data url from a blob.\n */\nexport function dataUrlFromBlob(blob) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = function () {\n            if (typeof reader.result === \"string\") {\n                resolve(reader.result);\n            }\n            else {\n                reject(new Error(`result type ${typeof reader.result}`));\n            }\n        };\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n}\n/**\n * Converts a audio to a chunk.\n */\nexport async function audioChunk(audio, metadata = {}) {\n    // TODO: Implement via media recorder as an option.\n    // const blob = await captureMediaFromElement(audio, maxDurationMs);\n    // return blobChunk(blob, metadata);\n    return fetchChunk(fetch(audio.src), metadata);\n}\n/**\n * Converts a video to a chunk.\n */\nexport async function videoChunk(video, metadata = {}) {\n    // TODO(doug): Implement via media recorder as an option.\n    return fetchChunk(fetch(video.src), metadata);\n}\n/**\n * Converts a fetch resource to a chunk.\n */\nexport async function fetchChunk(resp, metadata = {}) {\n    resp = await Promise.resolve(resp);\n    return blobChunk(await resp.blob(), metadata);\n}\n/**\n * Converts a blob to a chunk.\n */\nexport async function blobChunk(blob, metadata = {}) {\n    const defaultMetadata = {\n        captureTime: new Date(),\n    };\n    const mimetype = parseMimetype(blob.type);\n    return {\n        metadata: {\n            ...defaultMetadata,\n            ...metadata,\n            mimetype,\n        },\n        data: new Uint8Array(await blob.arrayBuffer()),\n    };\n}\n/**\n * Returns a chunk with the given metadata.\n */\nexport function withMetadata(chunk, metadata) {\n    return {\n        ...chunk,\n        metadata: {\n            ...chunk.metadata,\n            ...metadata,\n        },\n    };\n}\n/**\n * Returns true if the mimetype matches the given proto message type.\n */\nexport function isProtoMessage(mimeType, messageType) {\n    return (mimeType.type === 'application' &&\n        mimeType.subtype === 'x-protobuf' &&\n        mimeType.parameters?.['type'] === messageType);\n}\nexport const JSON_MIME_TYPE = {\n    type: 'application',\n    subtype: 'json',\n};\nexport const TEXT_MIME_TYPE = {\n    type: 'text',\n    subtype: 'plain',\n};\n", "/**\n * @fileoverview Library for working with lazy tree like stream of chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n// Polyfill for Promise.withResolvers\nif (typeof Promise.withResolvers === 'undefined') {\n    Promise.withResolvers = () => {\n        let resolve;\n        let reject;\n        const promise = new Promise((res, rej) => {\n            resolve = res;\n            reject = rej;\n        });\n        return { promise, resolve, reject };\n    };\n}\n/**\n * A writable AsyncIterable.\n */\nclass Stream {\n    closed = false;\n    children = [];\n    iterators = [];\n    errorValue;\n    /**\n     * Writes a value to the stream.\n     */\n    write(value) {\n        if (this.closed) {\n            throw new Error('Stream is closed');\n        }\n        this.children.push(value);\n        for (const iterator of [...this.iterators]) {\n            iterator.write(value);\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Write and close.\n     */\n    async writeAndClose(value) {\n        await this.write(value);\n        await this.close();\n    }\n    /**\n     * Closes the stream.\n     */\n    close() {\n        this.closed = true;\n        for (const iterator of [...this.iterators]) {\n            iterator.close();\n        }\n        return Promise.resolve();\n    }\n    get isClosed() {\n        return this.closed;\n    }\n    get size() {\n        return this.children.length;\n    }\n    get items() {\n        return [...this.children];\n    }\n    getError() {\n        return this.errorValue;\n    }\n    /*\n     * Errors the stream if there has been a problem.\n     */\n    error(reason) {\n        this.errorValue = reason;\n        this.closed = true;\n        for (const iterator of [...this.iterators]) {\n            iterator.error(reason);\n        }\n    }\n    /**\n     * Async iterator over the raw StreamItems being pushed in.\n     */\n    rawAsyncIterator() {\n        const iterator = new StreamIterator(this, this.children, () => {\n            const index = this.iterators.indexOf(iterator);\n            if (index >= 0) {\n                this.iterators.splice(index, 1);\n            }\n        });\n        this.iterators.push(iterator);\n        return iterator;\n    }\n    [Symbol.asyncIterator]() {\n        const iter = this.rawAsyncIterator();\n        const stream = iteratorToIterable(iter);\n        const chunks = (async function* () {\n            try {\n                yield* leaves(stream);\n            }\n            finally {\n                // Need to explicitly release this iterator memory.\n                if (iter.return) {\n                    void iter.return();\n                }\n            }\n        })();\n        return chunks[Symbol.asyncIterator]();\n    }\n    then = thenableAsyncIterable;\n}\nasync function* iteratorToIterable(iter) {\n    while (true) {\n        const result = await iter.next();\n        if (result.done)\n            break;\n        yield result.value;\n    }\n}\nclass StreamIterator {\n    stream;\n    done;\n    writeQueue = [];\n    readQueue = [];\n    constructor(stream, current, done) {\n        this.stream = stream;\n        this.done = done;\n        this.writeQueue = [...current];\n    }\n    write(value) {\n        const queued = this.readQueue.shift();\n        if (queued) {\n            queued.resolve({ done: false, value });\n        }\n        else {\n            this.writeQueue.push(value);\n        }\n    }\n    close() {\n        const queued = this.readQueue.shift();\n        if (queued) {\n            queued.resolve({ done: true, value: undefined });\n        }\n    }\n    error(error) {\n        const queued = this.readQueue.shift();\n        if (queued) {\n            queued.reject(error);\n        }\n    }\n    next() {\n        const value = this.writeQueue.shift();\n        if (value) {\n            return Promise.resolve({ done: false, value });\n        }\n        if (this.stream.getError() !== undefined) {\n            return Promise.reject(new Error(this.stream.getError()));\n        }\n        const done = this.writeQueue.length === 0 && this.stream.isClosed;\n        if (done) {\n            this.done();\n            return Promise.resolve({ done, value: undefined });\n        }\n        const next = Promise.withResolvers();\n        this.readQueue.push(next);\n        return next.promise;\n    }\n    return(value) {\n        this.done();\n        return Promise.resolve({ done: true, value });\n    }\n}\n/** Constructor function for creating a stream object. */\nexport function createStream() {\n    return new Stream();\n}\n/**\n * Returns true if the provided object implements the AsyncIterator protocol via\n * implementing a `Symbol.asyncIterator` method.\n */\nexport function isAsyncIterable(maybeAsyncIterable) {\n    const iter = maybeAsyncIterable;\n    return typeof iter[Symbol.asyncIterator] === 'function';\n}\n/**\n * Leaves of a Stream because the stream can be recursive this flattens it in\n * order.\n */\nasync function* leaves(items) {\n    if (items instanceof Array) {\n        for (const node of items) {\n            yield* leaves(node);\n        }\n    }\n    else if (isAsyncIterable(items)) {\n        for await (const node of items) {\n            yield* leaves(node);\n        }\n    }\n    else {\n        yield items;\n    }\n}\n/** A function to aggregate an AsyncIterable to a PromiseLike thenable. */\nexport function thenableAsyncIterable(onfulfilled, onrejected) {\n    const aggregate = async () => {\n        const items = [];\n        for await (const item of this) {\n            items.push(item);\n        }\n        return items;\n    };\n    return aggregate().then(onfulfilled, onrejected);\n}\n/** Make an asyncIterable PromiseLike. */\nexport function awaitableAsyncIterable(iter) {\n    const then = iter;\n    then.then = thenableAsyncIterable;\n    return then;\n}\n", "/**\n * @fileoverview Library for working with lazy tree like stream of chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { createStream, isAsyncIterable } from '../stream/index.js';\nimport { audioChunk, blobChunk, fetchChunk, ROLE, imageChunk, isChunk, textChunk, videoChunk, withMetadata, } from './content.js';\n/** Transform a series of unknown values to chunks with the exception of str. */\nfunction transformToContent(value, metadataFn) {\n    if (typeof window !== 'undefined') {\n        if (value instanceof HTMLImageElement) {\n            value = imageChunk(value);\n        }\n        else if (value instanceof HTMLAudioElement) {\n            value = audioChunk(value);\n        }\n        else if (value instanceof HTMLVideoElement) {\n            value = videoChunk(value);\n        }\n    }\n    if (typeof value === 'string') {\n        value = textChunk(value);\n    }\n    if (value instanceof Blob) {\n        value = blobChunk(value);\n    }\n    if (value instanceof Response) {\n        value = fetchChunk(value);\n    }\n    if (isChunk(value)) {\n        if (metadataFn) {\n            value = withMetadata(value, metadataFn(value));\n        }\n    }\n    if (value instanceof Promise) {\n        const pl = createStream();\n        value\n            .then(async (v) => {\n            if (isChunk(v)) {\n                if (metadataFn) {\n                    v = withMetadata(v, metadataFn(v));\n                }\n            }\n            else {\n                v = transformToContent(v, metadataFn);\n            }\n            await pl.write(v);\n            await pl.close();\n        })\n            .catch((err) => {\n            pl.error(`${err}`);\n        });\n        value = pl;\n    }\n    if (!assertIsContent(value)) {\n        throw new Error('Unsupported value type');\n    }\n    return value;\n}\n/**\n * Factory for a template literal for constructing a prompt with specific\n * metadata.\n */\nexport function promptLiteralWithMetadata(metadataFn) {\n    function prompt(strings, ...values) {\n        const node = [];\n        const l = values.length;\n        let str = '';\n        for (let i = 0; i < l; i++) {\n            str += strings[i];\n            let value = values[i];\n            // Empty values are treated as empty strings.\n            if (value === undefined || value === null) {\n                value = '';\n            }\n            if (typeof value === 'string') {\n                str += value;\n            }\n            else {\n                if (str) {\n                    let chunk = textChunk(str);\n                    if (metadataFn) {\n                        chunk = withMetadata(chunk, metadataFn(chunk));\n                    }\n                    node.push(chunk);\n                }\n                str = '';\n                node.push(transformToContent(value, metadataFn));\n            }\n        }\n        str += strings[l];\n        if (str) {\n            let chunk = textChunk(str);\n            if (metadataFn) {\n                chunk = withMetadata(chunk, metadataFn(chunk));\n            }\n            node.push(chunk);\n        }\n        if (node.length === 1) {\n            return node[0];\n        }\n        return node;\n    }\n    return prompt;\n}\nfunction assertIsContent(value) {\n    if (Array.isArray(value)) {\n        return value.every((v) => assertIsContent(v));\n    }\n    if (isChunk(value) || isAsyncIterable(value)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Template literal for constructing a prompt.\n */\nexport const prompt = promptLiteralWithMetadata();\n/**\n * Template literal for constructing a prompt but always with user role.\n */\nexport const userPrompt = promptLiteralWithMetadata(() => ({ role: ROLE.USER }));\n/**\n * Template literal for constructing a prompt but always with system role.\n */\nexport const systemPrompt = promptLiteralWithMetadata(() => ({\n    role: ROLE.SYSTEM,\n}));\n/**\n * Template literal for constructing a prompt but always with assistant role.\n */\nexport const assistantPrompt = promptLiteralWithMetadata(() => ({\n    role: ROLE.ASSISTANT,\n}));\n/**\n * Template literal for constructing a prompt but always with context role.\n */\nexport const contextPrompt = promptLiteralWithMetadata(() => ({\n    role: ROLE.CONTEXT,\n}));\n/**\n * Transforms a Content to a new Content with the given metadata.\n */\nexport function promptWithMetadata(prompt, metadata) {\n    if (isChunk(prompt)) {\n        const chunk = withMetadata(prompt, metadata);\n        return chunk;\n    }\n    else if (prompt instanceof Array) {\n        const list = prompt.map((child) => promptWithMetadata(child, metadata));\n        return list;\n    }\n    else if (isAsyncIterable(prompt)) {\n        const pipe = createStream();\n        const source = prompt;\n        const transform = async () => {\n            try {\n                for await (const item of source) {\n                    void pipe.write(promptWithMetadata(item, metadata));\n                }\n            }\n            catch (err) {\n                pipe.error(`${err}`);\n            }\n            finally {\n                await pipe.close();\n            }\n        };\n        void transform();\n        return pipe;\n    }\n    throw new Error(`Unsupported type ${prompt}`);\n}\n", "/**\n * @fileoverview Utilities for processing content chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n// TODO(doug): Parse sample rate and channels from the generator..\nconst DEFAULT_OUTPUT_SAMPLE_RATE = 24000;\nconst DEFAULT_INPUT_SAMPLE_RATE = 16000;\nconst DEFAULT_NUM_CHANNELS = 1;\nasync function decodeAudioData(chunk, ctx, sampleRate, numChannels) {\n    const data = chunk.data;\n    if (!data) {\n        throw new Error('Chunk without data.');\n    }\n    const buffer = ctx.createBuffer(numChannels, data.length / 2 / numChannels, sampleRate);\n    const mimetype = chunk.metadata?.mimetype;\n    if (!mimetype) {\n        throw new Error('Chunk without mimetype.');\n    }\n    if (mimetype.type === 'audio' && mimetype.subtype === 'ogg') {\n        // TODO(doug): Audio ogg processing is not working properly.\n        const blob = new Blob([data.buffer], { type: 'audio/ogg' });\n        const oggBuffer = await ctx.decodeAudioData(await blob.arrayBuffer());\n        for (let i = 0; i < numChannels; i++) {\n            buffer.copyToChannel(oggBuffer.getChannelData(i), i);\n        }\n    }\n    else if (mimetype.type === 'audio' && mimetype.subtype === 'pcm') {\n        const dataInt16 = new Int16Array(data.buffer);\n        const l = dataInt16.length;\n        const dataFloat32 = new Float32Array(l);\n        for (let i = 0; i < l; i++) {\n            dataFloat32[i] = dataInt16[i] / 32768.0;\n        }\n        // Extract interleaved channels\n        if (numChannels === 0) {\n            buffer.copyToChannel(dataFloat32, 0);\n        }\n        else {\n            for (let i = 0; i < numChannels; i++) {\n                const channel = dataFloat32.filter((_, index) => index % numChannels === i);\n                buffer.copyToChannel(channel, i);\n            }\n        }\n    }\n    else {\n        throw new Error(`Unsupported mime type: ${JSON.stringify(mimetype)}`);\n    }\n    return buffer;\n}\n/** Converts Audio Chunks to a Media Stream. */\nexport function audioChunksToMediaStream(chunks) {\n    const sampleRate = DEFAULT_OUTPUT_SAMPLE_RATE;\n    const numChannels = DEFAULT_NUM_CHANNELS;\n    const media = new MediaStream();\n    function nextContext(currentCtx) {\n        if (currentCtx) {\n            void currentCtx.close();\n        }\n        const nextCtx = new AudioContext({ sampleRate });\n        const nextDest = nextCtx.createMediaStreamDestination();\n        media.getTracks().forEach((t) => {\n            media.removeTrack(t);\n        });\n        nextDest.stream.getTracks().forEach((t) => {\n            media.addTrack(t);\n        });\n        return [nextCtx, nextDest];\n    }\n    ;\n    let [ctx, dest] = nextContext();\n    async function read() {\n        try {\n            let nextStartTime = 0;\n            for await (const chunk of chunks) {\n                if (chunk.metadata?.mimetype?.type !== 'audio') {\n                    continue;\n                }\n                const mimetypeParameters = chunk.metadata.mimetype.parameters;\n                // Use sample rate from chunk if present.\n                let chunkSampleRate = Number(mimetypeParameters?.['rate']);\n                if (isNaN(chunkSampleRate)) {\n                    chunkSampleRate = sampleRate;\n                }\n                // Has been a significant delay in next audio chunk.\n                if (ctx.currentTime > nextStartTime) {\n                    [ctx, dest] = nextContext(ctx);\n                    nextStartTime = ctx.currentTime;\n                }\n                let audioBuffer;\n                try {\n                    audioBuffer = await decodeAudioData(chunk, ctx, sampleRate, numChannels);\n                }\n                catch (e) {\n                    console.error('Error decoding audio data', e);\n                    continue;\n                }\n                const source = ctx.createBufferSource();\n                source.buffer = audioBuffer;\n                source.connect(dest);\n                source.start(nextStartTime);\n                nextStartTime = nextStartTime + audioBuffer.duration;\n            }\n            await ctx.close();\n        }\n        finally {\n            if (ctx.state !== 'closed') {\n                void ctx.close();\n            }\n        }\n    }\n    void read();\n    return media;\n}\n/** Converts a Media Stream to audio chunks. */\nexport async function* mediaStreamToAudioChunks(media) {\n    const sampleRate = DEFAULT_INPUT_SAMPLE_RATE;\n    const ctx = new AudioContext({ sampleRate });\n    const numChannels = DEFAULT_NUM_CHANNELS;\n    const src = ctx.createMediaStreamSource(media);\n    // TODO(doug): Use a worklet processor to convert to int16.\n    const BUFFER_SIZE = 8192; // must be a power of 2 between 256 and 16384\n    // eslint-disable-next-line @typescript-eslint/no-deprecated\n    const processor = ctx.createScriptProcessor(BUFFER_SIZE, numChannels, numChannels);\n    const queue = [];\n    let resolver = undefined;\n    // eslint-disable-next-line @typescript-eslint/no-deprecated\n    processor.onaudioprocess = (e) => {\n        // Data is float32, from -1 to 1.\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        const data = e.inputBuffer.getChannelData(0);\n        const l = data.length;\n        const int16 = new Int16Array(l);\n        for (let i = 0; i < l; i++) {\n            // convert float32 -1 to 1 to int16 -32768 to 32767\n            int16[i] = data[i] * 32768;\n        }\n        const chunk = {\n            data: new Uint8Array(int16.buffer),\n            metadata: {\n                mimetype: {\n                    type: 'audio',\n                    subtype: 'pcm',\n                    parameters: { 'rate': `${sampleRate}` },\n                },\n            },\n        };\n        if (resolver) {\n            resolver(chunk);\n            resolver = undefined;\n        }\n        else {\n            queue.push(chunk);\n        }\n    };\n    src.connect(processor);\n    processor.connect(ctx.destination);\n    try {\n        while (true) {\n            if (queue.length > 0) {\n                const result = queue.shift();\n                if (result === undefined) {\n                    continue;\n                }\n                yield result;\n            }\n            else {\n                const result = await new Promise((resolve) => {\n                    resolver = resolve;\n                });\n                yield result;\n            }\n            if (!media.active) {\n                break;\n            }\n        }\n    }\n    finally {\n        await ctx.close();\n    }\n}\n", "/**\n * @fileoverview Utilities for processing content chunks.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { dataUrlFromBlob, fetchChunk } from \"./content.js\";\nimport { stringifyMimetype } from \"./mime.js\";\n/** Converts image chunks to a Media Stream. */\nexport function imageChunksToMediaStream(chunks, options) {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    let first = true;\n    async function read() {\n        try {\n            for await (const c of chunks) {\n                if (c.metadata?.mimetype?.type !== 'image') {\n                    continue;\n                }\n                const img = new Image();\n                if (c.data) {\n                    img.src = await dataUrlFromBlob(new Blob([c.data], { type: stringifyMimetype(c.metadata?.mimetype) }));\n                }\n                else {\n                    throw new Error(`Not yet implemented ${JSON.stringify(c)}`);\n                }\n                if (first) {\n                    first = false;\n                    canvas.width = img.width;\n                    canvas.height = img.height;\n                    console.log(canvas.width, canvas.height);\n                }\n                ctx?.drawImage(img, 0, 0);\n            }\n        }\n        finally {\n            stream.getTracks().forEach(track => { track.stop(); });\n        }\n    }\n    void read();\n    const stream = canvas.captureStream(options?.frameRate);\n    return stream;\n}\nconst mediaToImageOptions = { frameRate: 1, scale: 0.5 };\n/** Converts a Media Stream to image chunks. */\nexport async function* mediaStreamToImageChunks(media, options = {}) {\n    const opts = { ...mediaToImageOptions, ...options };\n    const video = document.createElement('video');\n    video.srcObject = media;\n    video.autoplay = true;\n    video.muted = true;\n    await video.play();\n    const canvas = document.createElement('canvas');\n    canvas.width = video.videoWidth * opts.scale;\n    canvas.height = video.videoHeight * opts.scale;\n    const ctx = canvas.getContext('2d');\n    while (true) {\n        if (!media.active) {\n            break;\n        }\n        ctx?.drawImage(video, 0, 0, canvas.width, canvas.height);\n        const dataUrl = canvas.toDataURL('image/jpeg', 1.0);\n        yield (await fetchChunk(fetch(dataUrl)));\n        await new Promise((resolve) => {\n            setTimeout(resolve, 1000.0 / opts.frameRate);\n        });\n    }\n}\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nexport * from \"./session.js\";\nexport * from \"./local.js\";\nexport * as middleware from \"./middleware/index.js\";\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Returns the first promise to resolve and which index it came from.\n */\nfunction raceWithIndex(promises) {\n    const { promise, resolve, reject } = Promise.withResolvers();\n    const l = promises.length;\n    let complete = false;\n    for (let i = 0; i < l; i++) {\n        const p = promises[i];\n        p.then((v) => {\n            if (complete) {\n                return;\n            }\n            complete = true;\n            resolve([v, i]);\n        }).catch((e) => {\n            if (complete) {\n                return;\n            }\n            complete = true;\n            reject(e);\n        });\n    }\n    return promise;\n}\n/**\n * Races a list of streams returning the first value to resolve from any stream.\n */\nexport async function* merge(...arr) {\n    const sources = [...arr].map((p) => {\n        const iter = p;\n        if (typeof iter[Symbol.asyncIterator] === \"function\") {\n            return iter[Symbol.asyncIterator]();\n        }\n        return p;\n    });\n    const queue = sources.map((p) => p.next());\n    while (queue.length > 0) {\n        const [result, i] = await raceWithIndex(queue);\n        if (result.done) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            queue.splice(i, 1);\n            sources.splice(i, 1);\n        }\n        else {\n            queue[i] = sources[i].next();\n            yield result.value;\n        }\n    }\n}\n", "/**\n * @fileoverview Internal methods for the SDK.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nlet uniqueIdCounter = 1;\n/**\n * Test ony method to reset the unique id counter.\n */\nexport function _resetUniqueId() {\n    uniqueIdCounter = 1;\n}\n/**\n * Generates a unique id.\n */\nexport function uniqueId() {\n    return `${uniqueIdCounter++}`;\n}\n", "/**\n * @fileoverview Internal methods for the SDK.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { isAsyncIterable, thenableAsyncIterable } from '../stream/index.js';\nimport { merge } from '../async/index.js';\nimport { uniqueId } from './utils.js';\nclass SessionPipe {\n    context;\n    id = uniqueId();\n    seq = 0;\n    closed = false;\n    constructor(context) {\n        this.context = context;\n    }\n    [Symbol.asyncIterator]() {\n        return this.context.read(this.id)[Symbol.asyncIterator]();\n    }\n    async writeAndClose(content) {\n        if (content instanceof Array) {\n            const l = content.length;\n            for (let i = 0; i < l - 1; i++) {\n                await this.write(content[i]);\n            }\n            await this.writeAndClose(content[l - 1]);\n        }\n        else if (isAsyncIterable(content)) {\n            await this.write(content);\n            await this.close();\n        }\n        else {\n            await this.writeChunk(content, false);\n        }\n    }\n    async write(content) {\n        if (content instanceof Array) {\n            for (const item of content) {\n                await this.write(item);\n            }\n        }\n        else if (isAsyncIterable(content)) {\n            for await (const item of content) {\n                await this.write(item);\n            }\n        }\n        else {\n            await this.writeChunk(content, true);\n        }\n    }\n    error(reason) {\n        this.context.error(this.id, reason);\n    }\n    async writeChunk(chunk, continued) {\n        const options = { seq: this.seq, continued };\n        this.seq++;\n        if (!continued) {\n            this.closed = true;\n        }\n        await this.context.write(this.id, chunk, options);\n    }\n    async close() {\n        // TODO(dougfritz): Should this close by id in the context?\n        if (this.closed) {\n            console.warn('Already closed.');\n            return;\n        }\n        this.closed = true;\n        const seq = this.seq++;\n        await this.context.write(this.id, emptyChunk, { seq, continued: false });\n    }\n    then = thenableAsyncIterable;\n}\nconst emptyChunk = {\n    metadata: {},\n    data: new Uint8Array(0)\n};\nfunction isAction(maybeAction) {\n    if (maybeAction.run) {\n        return true;\n    }\n    return false;\n}\n/** Session wrapper given a SessionContext. */\nclass Session {\n    context;\n    constructor(context) {\n        this.context = context;\n    }\n    createPipe(content) {\n        const pipe = new SessionPipe(this.context);\n        if (content) {\n            void pipe.writeAndClose(content);\n        }\n        return pipe;\n    }\n    run(actionOrProcessor, inputs, outputs) {\n        // TODO(dougfritz): Verify that the inputs and outputs are in the current session\n        const outs = Object.fromEntries(outputs.map((k) => [k, this.createPipe()]));\n        // context.\n        if (isAction(actionOrProcessor)) {\n            void actionOrProcessor.run(this, inputs, outs);\n        }\n        else {\n            void writeOutputs(actionOrProcessor(joinInputs(inputs)), outs);\n        }\n        return outs;\n    }\n    async close() {\n        await this.context.close();\n    }\n}\n/** Adds the name to each item in the Chunk stream. */\nasync function* withName(name, stream) {\n    for await (const c of stream) {\n        yield [name, c];\n    }\n}\n/** Joins the inputs in the dict into an eager stream of chunks with named key. */\nasync function* joinInputs(inputs) {\n    const streams = Object.keys(inputs).map((k) => withName(k, inputs[k]));\n    yield* merge(...streams);\n}\n/** Writes the unified stream of outputs to a dict of writable streams. */\nasync function writeOutputs(unified, outputs) {\n    for await (const [k, c] of unified) {\n        void outputs[k].write(c);\n    }\n    for (const v of Object.values(outputs)) {\n        await v.close();\n    }\n}\n/** Provides a session. */\nexport function sessionProvider(contextProvider) {\n    return (...middleware) => {\n        let c = contextProvider();\n        if (middleware) {\n            for (const m of middleware.reverse()) {\n                c = m(c);\n            }\n        }\n        return new Session(c);\n    };\n}\n", "/**\n * @fileoverview Local session.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { createStream } from \"../stream/stream.js\";\nimport { sessionProvider } from \"./session.js\";\nclass LocalContext {\n    nodeMap = new Map();\n    sequenceOrder = new Map();\n    createStream(id) {\n        const pl = createStream();\n        this.nodeMap.set(id, pl);\n        this.sequenceOrder.set(id, -1);\n        return pl;\n    }\n    async write(id, chunk, options) {\n        let pl = this.nodeMap.get(id);\n        if (pl === undefined) {\n            pl = this.createStream(id);\n        }\n        const lastSeq = this.sequenceOrder.get(id);\n        if (lastSeq === undefined) {\n            throw new Error(`Sequence not found for ${id}`);\n        }\n        const seq = options?.seq ?? 0;\n        if ((lastSeq + 1) !== seq) {\n            throw new Error(`Out of order sequence writes not yet supported. last seq ${lastSeq}, current seq ${seq}`);\n        }\n        this.sequenceOrder.set(id, seq);\n        // Skip writing empty data and ref as it is just a close signal explicit check.\n        if (chunk.data !== undefined || chunk.ref !== undefined) {\n            await pl.write(chunk);\n        }\n        const continued = options?.continued ?? false;\n        if (!continued) {\n            await pl.close();\n        }\n    }\n    error(id, reason) {\n        const pl = this.nodeMap.get(id);\n        if (pl === undefined) {\n            throw new Error(`No such id exists ${id}`);\n        }\n        pl.error(reason);\n    }\n    read(id) {\n        let pl = this.nodeMap.get(id);\n        if (pl === undefined) {\n            pl = this.createStream(id);\n        }\n        return pl;\n    }\n    ;\n    async close() {\n        for (const stream of this.nodeMap.values()) {\n            await stream.close();\n        }\n        this.nodeMap.clear();\n        this.sequenceOrder.clear();\n    }\n}\nexport const local = sessionProvider(() => new LocalContext());\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nexport * from './debug.js';\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { chunkText } from \"../../content/content.js\";\nclass DebugContext {\n    context;\n    constructor(context) {\n        this.context = context;\n    }\n    read(id) {\n        async function* readAndLog(context) {\n            for await (const chunk of context.read(id)) {\n                console.log(`Reading from ${id}`, chunkText(chunk));\n                yield chunk;\n            }\n        }\n        return readAndLog(this.context);\n    }\n    async write(id, chunk, options) {\n        console.log(`Writing ${id}`, chunkText(chunk), options?.seq, options?.continued);\n        await this.context.write(id, chunk, options);\n    }\n    error(id, reason) {\n        console.error(reason);\n        this.context.error(id, reason);\n    }\n    async close() {\n        await this.context.close();\n    }\n}\nexport const debug = (context) => {\n    return new DebugContext(context);\n};\n", "/**\n * @fileoverview Index export.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nexport * from \"./common.js\";\nexport * from \"./toy.js\";\nexport * as google from './google/index.js';\nexport * as drive from './drive/index.js';\nexport * as evergreen from './evergreen/index.js';\n", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Action } from '../interfaces.js';\n/** Well defined GenerateContent Action */\nexport class GenerateContent extends Action {\n}\n/** Well defined Live Action */\nexport class Live extends Action {\n}\n", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Action } from '../interfaces.js';\nimport { chunkText, textChunk, ROLE } from '../content/content.js';\n/** Reverse some content. */\nexport class ReverseContent extends Action {\n    async run(session, inputs, outputs) {\n        for await (const chunk of inputs.prompt) {\n            const text = chunkText(chunk);\n            const reverse = text.split(\"\").reverse().join(\"\");\n            await outputs.response.write(textChunk(reverse, { role: ROLE.ASSISTANT }));\n        }\n        await outputs.response.close();\n    }\n}\n", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nexport * as genai from './genai.js';\n", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GoogleGenAI, Modality } from \"@google/genai\";\nimport { GenerateContent as AbstractGenerateContent, Live as AbstractLive } from '../common.js';\nimport { chunkText, textChunk } from '../../content/content.js';\nimport { parseMimetype, stringifyMimetype } from '../../content/mime.js';\nimport { encode as b64encode, decode as b64decode } from '../../base64/index.js';\nimport { merge } from '../../async/index.js';\nconst clients = new Map();\nfunction genAI(apiKey) {\n    let client = clients.get(apiKey);\n    if (!client) {\n        client = new GoogleGenAI({ apiKey, apiVersion: 'v1alpha' });\n        clients.set(apiKey, client);\n    }\n    return client;\n}\nexport class Live extends AbstractLive {\n    apiKey;\n    model;\n    constructor(apiKey, model = 'gemini-2.0-flash-exp') {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n    }\n    async run(session, inputs, outputs) {\n        const client = genAI(this.apiKey);\n        const config = {\n            responseModalities: [Modality.AUDIO]\n        };\n        if (inputs.system) {\n            const system = await inputs.system;\n            const systemString = system.map((c) => chunkText(c)).join(\"\");\n            config.systemInstruction = {\n                parts: [{ text: systemString }],\n            };\n        }\n        const live = await client.live.connect({\n            model: this.model, config, callbacks: {\n                onmessage: (e) => {\n                    void onmessage(e);\n                },\n                onerror: (e) => {\n                    console.log('error', e);\n                },\n                onclose: (e) => {\n                    console.log('close', e);\n                },\n                onopen: () => {\n                    console.log('open');\n                },\n            }\n        });\n        async function readInputs() {\n            const arr = [inputs.audio, inputs.video, inputs.screen].filter((x) => !!x);\n            if (arr.length === 0)\n                return;\n            for await (const chunk of merge(...arr)) {\n                if (chunk.data) {\n                    live.sendRealtimeInput({\n                        media: {\n                            mimeType: stringifyMimetype(chunk.metadata.mimetype),\n                            data: b64encode(chunk.data),\n                        }\n                    });\n                }\n            }\n        }\n        async function readContext() {\n            if (!inputs.context) {\n                return;\n            }\n            for await (const chunk of inputs.context) {\n                if (chunk.data) {\n                    live.sendClientContent({\n                        turns: [{\n                                parts: [{\n                                        text: chunkText(chunk),\n                                    }],\n                            }],\n                        turnComplete: false,\n                    });\n                }\n            }\n        }\n        async function onmessage(resp) {\n            if (resp.serverContent?.modelTurn) {\n                const turn = resp.serverContent.modelTurn;\n                if (turn.parts) {\n                    for (const part of turn.parts) {\n                        if (part.text) {\n                            const chunk = textChunk(part.text);\n                            await outputs.context?.write(chunk);\n                        }\n                        else if (part.inlineData) {\n                            const chunk = {\n                                data: b64decode(part.inlineData.data ?? ''),\n                                metadata: {\n                                    mimetype: parseMimetype(part.inlineData.mimeType),\n                                }\n                            };\n                            if (chunk.metadata?.mimetype?.type === 'audio') {\n                                await outputs.audio?.write(chunk);\n                            }\n                            else {\n                                await outputs.context?.write(chunk);\n                            }\n                        }\n                    }\n                }\n            }\n            if (resp.serverContent?.turnComplete) {\n                console.log('complete turn');\n                return;\n            }\n            if (resp.serverContent?.interrupted) {\n                console.log('interupted turn');\n                return;\n            }\n            if (resp.toolCall) {\n                console.log('toolCall');\n                return;\n            }\n            if (resp.toolCallCancellation) {\n                console.log('toolCancellation');\n                return;\n            }\n        }\n        async function writeOutputs() {\n            await new Promise(() => {\n                // TODO(doug): When should this actually finish and close.\n                // await outputs.context?.close();\n                // await outputs.audio?.close();\n            });\n        }\n        void readInputs();\n        void readContext();\n        await writeOutputs();\n    }\n}\n/** Well defined GenerateContent Action */\nexport class GenerateContent extends AbstractGenerateContent {\n    apiKey;\n    model;\n    constructor(apiKey, model) {\n        super();\n        this.apiKey = apiKey;\n        this.model = model;\n    }\n    async run(session, inputs, outputs) {\n        if (!outputs.response) {\n            return;\n        }\n        const prompt = await inputs.prompt;\n        const promptString = prompt.map((c) => chunkText(c)).join(\"\");\n        const response = await genAI(this.apiKey).models.generateContentStream({\n            model: this.model,\n            contents: promptString,\n        });\n        for await (const chunk of response) {\n            const text = chunk.text;\n            if (text) {\n                await outputs.response.write(textChunk(text));\n            }\n        }\n    }\n}\n", "/**\n * @fileoverview base64 helper utilities.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n/** Encodes Uint8Array to base64 string. */\nexport function encode(bytes) {\n    let binary = '';\n    const len = bytes.byteLength;\n    for (let i = 0; i < len; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n/** Decodes base64 string to Uint8Array. */\nexport function decode(base64) {\n    const binaryString = atob(base64);\n    const len = binaryString.length;\n    const bytes = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}\n", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nexport * from './drive.js';\n", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n// Create an OAuth client ID at https://console.cloud.google.com/apis/credentials.\nlet OAUTH_CLIENT_ID = '';\nconst OAUTH_SCOPES = ['https://www.googleapis.com/auth/documents.readonly'];\nfunction oauthSignIn() {\n    const oauth2Endpoint = 'https://accounts.google.com/o/oauth2/v2/auth';\n    const form = document.createElement('form');\n    form.setAttribute('method', 'GET');\n    form.setAttribute('action', oauth2Endpoint);\n    if (!OAUTH_CLIENT_ID) {\n        OAUTH_CLIENT_ID = prompt(\"Google OAuth client\") ?? '';\n    }\n    const params = {\n        'client_id': OAUTH_CLIENT_ID,\n        // TODO: update with the URL if this is hosted persistently.\n        // Register the domain under \"Authorized JavaScript origins\" and\n        // \"Authorized redirect URIs\" in the Google Cloud console.\n        'redirect_uri': 'http://localhost:5432/examples/drive',\n        'response_type': 'token',\n        'scope': OAUTH_SCOPES.join(' '),\n        'include_granted_scopes': 'true',\n        'state': 'pass-through value'\n    };\n    for (const [k, v] of Object.entries(params)) {\n        const input = document.createElement('input');\n        input.setAttribute('type', 'hidden');\n        input.setAttribute('name', k);\n        input.setAttribute('value', v);\n        form.appendChild(input);\n    }\n    document.body.appendChild(form);\n    form.submit();\n}\nlet authTried = false;\nexport function maybeAuthenticate() {\n    if (authTried) {\n        return;\n    }\n    authTried = true;\n    const fragmentString = location.hash.substring(1);\n    const params = {};\n    const regex = /([^&=]+)=([^&]*)/g;\n    let m = null;\n    while ((m = regex.exec(fragmentString)) !== null) {\n        params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);\n    }\n    if (Object.keys(params).length > 0 && params['state']) {\n        const paramsJson = JSON.stringify(params);\n        localStorage.setItem('oauth2-test-params', paramsJson);\n    }\n    else {\n        oauthSignIn();\n    }\n}\n", "/**\n * @fileoverview Generate content.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { textChunk, chunkText } from '../../content/content.js';\nimport { maybeAuthenticate } from './auth.js';\nconst DOCS_API = 'https://docs.googleapis.com/v1/documents/';\nfunction documentToText(document) {\n    let documentText = '';\n    documentText += document.title + '<br><br>';\n    for (const content of document.body.content) {\n        if (content.paragraph) {\n            for (const element of content.paragraph.elements) {\n                if (element.textRun.content) {\n                    documentText += element.textRun.content;\n                }\n            }\n        }\n    }\n    return documentText;\n}\nasync function fetchDocument(url) {\n    const match = /\\/d\\/([a-zA-Z0-9-_]+)/.exec(url);\n    if (!match) {\n        throw new Error(`Bad url ${url}`);\n    }\n    const docsId = match[1];\n    const docsApi = `${DOCS_API}${docsId}`;\n    const params = JSON.parse(localStorage.getItem('oauth2-test-params') ?? '{}');\n    const response = await fetch(`${docsApi}?access_token=${params.access_token}`);\n    const documentData = await response.json();\n    return documentData;\n}\n/** Converts a docUrl imput to docText. */\nexport const docToText = async function* (chunks) {\n    maybeAuthenticate();\n    for await (const [k, c] of chunks) {\n        if (k === 'docUrl') {\n            const document = await fetchDocument(chunkText(c));\n            const documentText = documentToText(document);\n            yield ['docText', textChunk(documentText)];\n        }\n        else {\n            yield [k, c];\n        }\n    }\n};\n", "/**\n * @fileoverview Evergreen.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nexport * from './run.js';\nexport * from './registry.js';\nexport * from './actions.js';\nexport * from './interfaces.js';\n", "/**\n * @fileoverview Evergreen actions.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { decode as b64decode, encode as b64encode } from '../../base64/index.js';\nimport { parseMimetype, stringifyMimetype } from '../../content/mime.js';\nimport { Action } from '../../interfaces.js';\nconst socketMap = new Map();\nasync function getSocket(session) {\n    let socket = socketMap.get(session);\n    if (socket && socket.readyState !== WebSocket.OPEN) {\n        socket = undefined;\n        socketMap.delete(session);\n    }\n    if (!socket) {\n        const s = new WebSocket(getBackend());\n        s.binaryType = 'blob';\n        await new Promise((resolve, reject) => {\n            s.addEventListener('open', () => {\n                s.removeEventListener('error', reject);\n                s.removeEventListener('close', reject);\n                resolve();\n            });\n            s.addEventListener('error', reject);\n            s.addEventListener('close', reject);\n        });\n        socket = s;\n        socketMap.set(session, s);\n    }\n    return socket;\n}\nfunction getUuids(inputs, outputs) {\n    const outputIds = {};\n    for (const output of Object.keys(outputs)) {\n        outputIds[output] = crypto.randomUUID();\n    }\n    const inputIds = {};\n    for (const input of Object.keys(inputs)) {\n        inputIds[input] = crypto.randomUUID();\n    }\n    return [inputIds, outputIds];\n}\nfunction handleMessages(socket, callbacks) {\n    // Set up the reading of the response.\n    socket.onmessage = async (event) => {\n        let message;\n        switch (event.type) {\n            case 'text':\n            case 'message':\n            case 'binary':\n                const data = event.data;\n                if (data instanceof Blob) {\n                    const buf = await data.arrayBuffer();\n                    message = JSON.parse(new TextDecoder().decode(new Uint8Array(buf)));\n                }\n                else if (data instanceof ArrayBuffer) {\n                    message =\n                        JSON.parse(new TextDecoder().decode(new Uint8Array(data)));\n                }\n                else if (typeof data === 'string') {\n                    message = JSON.parse(data);\n                }\n                else {\n                    throw new Error(`Unsupported type ${socket.binaryType} ${typeof data}`);\n                }\n                break;\n            default:\n                throw new Error(`Unknown message type ${event.type}`);\n        }\n        console.log('message', message);\n        callbacks.onmessage(message);\n    };\n    socket.onerror = (event) => {\n        console.info('Websocket error', event, socket);\n        callbacks.onerror(event);\n    };\n    socket.onclose = (event) => {\n        // See\n        // https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code#value\n        // for mapping from code to explanation.\n        console.info(`Websocket closed: ${event.reason} ${event.code}`, event, socket);\n        callbacks.onclose(event);\n    };\n}\nfunction writeToOutputs(msg, outputIds, outputs) {\n    for (const nodeFragment of msg.nodeFragments || []) {\n        const key = nodeFragment.id;\n        if (!key) {\n            continue;\n        }\n        const stream = outputs[key];\n        const metadata = {\n            mimetype: parseMimetype(nodeFragment.chunkFragment?.metadata?.mimetype),\n            role: nodeFragment.chunkFragment?.metadata?.role,\n        };\n        const data = nodeFragment.chunkFragment?.data ?\n            b64decode(nodeFragment.chunkFragment.data) :\n            undefined;\n        const ref = nodeFragment.chunkFragment?.ref;\n        const chunk = data ? { metadata, data } : ref ? { metadata, ref } : { metadata };\n        stream.write(chunk);\n        if (!nodeFragment.continued) {\n            stream.close();\n        }\n    }\n}\nfunction sendAction(socket, uri, action, inputIds, outputIds) {\n    const actionMessage = {\n        actions: [\n            {\n                targetSpec: {\n                    id: uri,\n                },\n                name: action.name,\n                inputs: Object.keys(inputIds).map((input) => {\n                    return {\n                        name: input,\n                        id: inputIds[input],\n                    };\n                }),\n                outputs: Object.keys(outputIds).map((output) => {\n                    return {\n                        name: output,\n                        id: outputIds[output],\n                    };\n                }),\n            },\n        ],\n    };\n    socket.send(JSON.stringify(actionMessage));\n}\n// Read the response.\nasync function read(socket, inputs, inputIds) {\n    for (const [k, v] of Object.entries(inputs)) {\n        void (async (key, stream) => {\n            let seq = 0;\n            for await (const chunk of stream) {\n                const chunkFragment = {};\n                chunkFragment.metadata = {\n                    mimetype: stringifyMimetype(chunk.metadata?.mimetype),\n                    role: chunk.metadata?.role,\n                };\n                if (chunk.data) {\n                    chunkFragment.data = b64encode(chunk.data);\n                }\n                const dataMsg = {\n                    nodeFragments: [\n                        {\n                            id: inputIds[key],\n                            chunkFragment,\n                            seq: seq++,\n                            continued: true,\n                        },\n                    ],\n                };\n                socket.send(JSON.stringify(dataMsg));\n            }\n            // close\n            const closeMsg = {\n                nodeFragments: [\n                    {\n                        id: inputIds[key],\n                        seq: seq++,\n                        continued: false,\n                    },\n                ],\n            };\n            socket.send(JSON.stringify(closeMsg));\n        })(k, v);\n    }\n}\nasync function runEvergreenAction(session, uri, action, inputs, outputs) {\n    const socket = await getSocket(session);\n    // Create uuids for the input and output streams.\n    const [inputIds, outputIds] = getUuids(inputs, outputs);\n    handleMessages(socket, {\n        onmessage: (msg) => {\n            console.log('message', msg);\n            writeToOutputs(msg, outputIds, outputs);\n        },\n        onerror: (event) => {\n            console.log('error', event);\n        },\n        onclose: (event) => {\n            console.log('close', event);\n        },\n    });\n    sendAction(socket, uri, action, inputIds, outputIds);\n    const readPromise = read(socket, inputs, inputIds);\n    await readPromise;\n    // TODO(doug): await all the writes to finish.\n}\nclass EvergreenAction extends Action {\n    uri;\n    action;\n    constructor(uri, action) {\n        super();\n        this.uri = uri;\n        this.action = action;\n    }\n    async run(session, inputs, outputs) {\n        await runEvergreenAction(session, this.uri, this.action, inputs, outputs);\n    }\n}\nlet lazyBackend = undefined;\n/** Sets the backend address wss://myapi/adddress?key=mykey. */\nexport function setBackend(address) {\n    lazyBackend = address;\n}\nfunction getBackend() {\n    if (lazyBackend === undefined) {\n        throw new Error('No backend address set, call setBackend().');\n    }\n    return lazyBackend;\n}\nexport function action(uri, action) {\n    return new EvergreenAction(uri, action);\n}\n", "/**\n * @fileoverview Evergreen actions.\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n/** Generate action */\nexport const GENERATE = {\n    name: 'GENERATE',\n    inputs: [\n        {\n            name: 'prompt',\n            description: 'The prompt to generate from',\n            type: [\n                { type: 'text', subtype: 'plain' },\n                { type: 'image', subtype: 'png' },\n            ],\n        },\n    ],\n    outputs: [\n        {\n            name: 'response',\n            description: 'The response from the model',\n            type: [\n                { type: 'text', subtype: 'plain' },\n                { type: 'image', subtype: 'png' },\n            ],\n        },\n    ],\n};\n"],
  "mappings": "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",
  "names": ["prompt", "ROLE", "prompt", "read", "read", "GenerateContent", "Live", "Live", "writeOutputs", "GenerateContent", "prompt", "document", "action"]
}
